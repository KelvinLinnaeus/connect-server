// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
    space_id, reporter_id, content_type, content_id, reason, description, priority
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type CreateReportParams struct {
	SpaceID     uuid.UUID      `json:"space_id"`
	ReporterID  uuid.UUID      `json:"reporter_id"`
	ContentType string         `json:"content_type"`
	ContentID   uuid.UUID      `json:"content_id"`
	Reason      string         `json:"reason"`
	Description sql.NullString `json:"description"`
	Priority    sql.NullString `json:"priority"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, createReport,
		arg.SpaceID,
		arg.ReporterID,
		arg.ContentType,
		arg.ContentID,
		arg.Reason,
		arg.Description,
		arg.Priority,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getContentModerationStats = `-- name: GetContentModerationStats :one
SELECT 
    COUNT(*) as total_reports,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_reports,
    COUNT(*) FILTER (WHERE status = 'approved') as approved_reports,
    COUNT(*) FILTER (WHERE status = 'rejected') as rejected_reports,
    COUNT(*) FILTER (WHERE priority = 'urgent') as urgent_reports
FROM reports 
WHERE space_id = $1
`

type GetContentModerationStatsRow struct {
	TotalReports    int64 `json:"total_reports"`
	PendingReports  int64 `json:"pending_reports"`
	ApprovedReports int64 `json:"approved_reports"`
	RejectedReports int64 `json:"rejected_reports"`
	UrgentReports   int64 `json:"urgent_reports"`
}

func (q *Queries) GetContentModerationStats(ctx context.Context, spaceID uuid.UUID) (GetContentModerationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getContentModerationStats, spaceID)
	var i GetContentModerationStatsRow
	err := row.Scan(
		&i.TotalReports,
		&i.PendingReports,
		&i.ApprovedReports,
		&i.RejectedReports,
		&i.UrgentReports,
	)
	return i, err
}

const getEngagementMetrics = `-- name: GetEngagementMetrics :many
SELECT 
    DATE(created_at) as date,
    COUNT(*) as post_count,
    SUM(likes_count) as total_likes,
    SUM(comments_count) as total_comments,
    SUM(views_count) as total_views
FROM posts 
WHERE space_id = $1 AND created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date
`

type GetEngagementMetricsRow struct {
	Date          time.Time `json:"date"`
	PostCount     int64     `json:"post_count"`
	TotalLikes    int64     `json:"total_likes"`
	TotalComments int64     `json:"total_comments"`
	TotalViews    int64     `json:"total_views"`
}

func (q *Queries) GetEngagementMetrics(ctx context.Context, spaceID uuid.UUID) ([]GetEngagementMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEngagementMetrics, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEngagementMetricsRow{}
	for rows.Next() {
		var i GetEngagementMetricsRow
		if err := rows.Scan(
			&i.Date,
			&i.PostCount,
			&i.TotalLikes,
			&i.TotalComments,
			&i.TotalViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentoringStats = `-- name: GetMentoringStats :one
SELECT
    COUNT(*) as total_sessions,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_sessions,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_sessions,
    COALESCE(AVG(rating), 0) as average_rating,
    COUNT(*) FILTER (WHERE rating IS NOT NULL) as rated_sessions
FROM mentoring_sessions
WHERE space_id = $1
`

type GetMentoringStatsRow struct {
	TotalSessions     int64       `json:"total_sessions"`
	CompletedSessions int64       `json:"completed_sessions"`
	PendingSessions   int64       `json:"pending_sessions"`
	AverageRating     interface{} `json:"average_rating"`
	RatedSessions     int64       `json:"rated_sessions"`
}

func (q *Queries) GetMentoringStats(ctx context.Context, spaceID uuid.UUID) (GetMentoringStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getMentoringStats, spaceID)
	var i GetMentoringStatsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.CompletedSessions,
		&i.PendingSessions,
		&i.AverageRating,
		&i.RatedSessions,
	)
	return i, err
}

const getModerationQueue = `-- name: GetModerationQueue :many
SELECT 
    r.id, r.space_id, r.reporter_id, r.content_type, r.content_id, r.reason, r.description, r.status, r.priority, r.reviewed_by, r.reviewed_at, r.moderation_notes, r.actions_taken, r.created_at, r.updated_at,
    u.username as reporter_username,
    u.full_name as reporter_full_name,
    reviewer.username as reviewer_username
FROM reports r
JOIN users u ON r.reporter_id = u.id
LEFT JOIN users reviewer ON r.reviewed_by = reviewer.id
WHERE r.space_id = $1
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type GetModerationQueueParams struct {
	SpaceID uuid.UUID `json:"space_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type GetModerationQueueRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	ReporterID       uuid.UUID             `json:"reporter_id"`
	ContentType      string                `json:"content_type"`
	ContentID        uuid.UUID             `json:"content_id"`
	Reason           string                `json:"reason"`
	Description      sql.NullString        `json:"description"`
	Status           sql.NullString        `json:"status"`
	Priority         sql.NullString        `json:"priority"`
	ReviewedBy       uuid.NullUUID         `json:"reviewed_by"`
	ReviewedAt       sql.NullTime          `json:"reviewed_at"`
	ModerationNotes  sql.NullString        `json:"moderation_notes"`
	ActionsTaken     pqtype.NullRawMessage `json:"actions_taken"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ReporterUsername string                `json:"reporter_username"`
	ReporterFullName string                `json:"reporter_full_name"`
	ReviewerUsername sql.NullString        `json:"reviewer_username"`
}

func (q *Queries) GetModerationQueue(ctx context.Context, arg GetModerationQueueParams) ([]GetModerationQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, getModerationQueue, arg.SpaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModerationQueueRow{}
	for rows.Next() {
		var i GetModerationQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.ReporterID,
			&i.ContentType,
			&i.ContentID,
			&i.Reason,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ModerationNotes,
			&i.ActionsTaken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReporterUsername,
			&i.ReporterFullName,
			&i.ReviewerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingReports = `-- name: GetPendingReports :many
SELECT 
    r.id, r.space_id, r.reporter_id, r.content_type, r.content_id, r.reason, r.description, r.status, r.priority, r.reviewed_by, r.reviewed_at, r.moderation_notes, r.actions_taken, r.created_at, r.updated_at,
    u.username as reporter_username,
    u.full_name as reporter_full_name
FROM reports r
JOIN users u ON r.reporter_id = u.id
WHERE r.space_id = $1 AND r.status = 'pending'
ORDER BY 
    CASE r.priority
        WHEN 'urgent' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        ELSE 4
    END,
    r.created_at DESC
`

type GetPendingReportsRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	ReporterID       uuid.UUID             `json:"reporter_id"`
	ContentType      string                `json:"content_type"`
	ContentID        uuid.UUID             `json:"content_id"`
	Reason           string                `json:"reason"`
	Description      sql.NullString        `json:"description"`
	Status           sql.NullString        `json:"status"`
	Priority         sql.NullString        `json:"priority"`
	ReviewedBy       uuid.NullUUID         `json:"reviewed_by"`
	ReviewedAt       sql.NullTime          `json:"reviewed_at"`
	ModerationNotes  sql.NullString        `json:"moderation_notes"`
	ActionsTaken     pqtype.NullRawMessage `json:"actions_taken"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ReporterUsername string                `json:"reporter_username"`
	ReporterFullName string                `json:"reporter_full_name"`
}

func (q *Queries) GetPendingReports(ctx context.Context, spaceID uuid.UUID) ([]GetPendingReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingReports, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingReportsRow{}
	for rows.Next() {
		var i GetPendingReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.ReporterID,
			&i.ContentType,
			&i.ContentID,
			&i.Reason,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ModerationNotes,
			&i.ActionsTaken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReporterUsername,
			&i.ReporterFullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularIndustries = `-- name: GetPopularIndustries :many
SELECT
    industry,
    COUNT(*) as session_count,
    AVG(ms.rating) as average_rating
FROM mentor_profiles mp
JOIN mentoring_sessions ms ON mp.user_id = ms.mentor_id
WHERE mp.space_id = $1 AND ms.status = 'completed'
GROUP BY industry
ORDER BY session_count DESC
LIMIT 10
`

type GetPopularIndustriesRow struct {
	Industry      string  `json:"industry"`
	SessionCount  int64   `json:"session_count"`
	AverageRating float64 `json:"average_rating"`
}

func (q *Queries) GetPopularIndustries(ctx context.Context, spaceID uuid.UUID) ([]GetPopularIndustriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularIndustries, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularIndustriesRow{}
	for rows.Next() {
		var i GetPopularIndustriesRow
		if err := rows.Scan(&i.Industry, &i.SessionCount, &i.AverageRating); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularSubjects = `-- name: GetPopularSubjects :many
SELECT 
    subject,
    COUNT(*) as session_count,
    AVG(rating) as average_rating
FROM tutoring_sessions 
WHERE space_id = $1 AND status = 'completed'
GROUP BY subject
ORDER BY session_count DESC
LIMIT 10
`

type GetPopularSubjectsRow struct {
	Subject       string  `json:"subject"`
	SessionCount  int64   `json:"session_count"`
	AverageRating float64 `json:"average_rating"`
}

func (q *Queries) GetPopularSubjects(ctx context.Context, spaceID uuid.UUID) ([]GetPopularSubjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularSubjects, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularSubjectsRow{}
	for rows.Next() {
		var i GetPopularSubjectsRow
		if err := rows.Scan(&i.Subject, &i.SessionCount, &i.AverageRating); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReport = `-- name: GetReport :one
SELECT 
    r.id, r.space_id, r.reporter_id, r.content_type, r.content_id, r.reason, r.description, r.status, r.priority, r.reviewed_by, r.reviewed_at, r.moderation_notes, r.actions_taken, r.created_at, r.updated_at,
    u.username as reporter_username,
    u.full_name as reporter_full_name,
    reviewer.username as reviewer_username
FROM reports r
JOIN users u ON r.reporter_id = u.id
LEFT JOIN users reviewer ON r.reviewed_by = reviewer.id
WHERE r.id = $1
`

type GetReportRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	ReporterID       uuid.UUID             `json:"reporter_id"`
	ContentType      string                `json:"content_type"`
	ContentID        uuid.UUID             `json:"content_id"`
	Reason           string                `json:"reason"`
	Description      sql.NullString        `json:"description"`
	Status           sql.NullString        `json:"status"`
	Priority         sql.NullString        `json:"priority"`
	ReviewedBy       uuid.NullUUID         `json:"reviewed_by"`
	ReviewedAt       sql.NullTime          `json:"reviewed_at"`
	ModerationNotes  sql.NullString        `json:"moderation_notes"`
	ActionsTaken     pqtype.NullRawMessage `json:"actions_taken"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ReporterUsername string                `json:"reporter_username"`
	ReporterFullName string                `json:"reporter_full_name"`
	ReviewerUsername sql.NullString        `json:"reviewer_username"`
}

func (q *Queries) GetReport(ctx context.Context, id uuid.UUID) (GetReportRow, error) {
	row := q.db.QueryRowContext(ctx, getReport, id)
	var i GetReportRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReporterUsername,
		&i.ReporterFullName,
		&i.ReviewerUsername,
	)
	return i, err
}

const getReportsByContent = `-- name: GetReportsByContent :many
SELECT id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
FROM reports 
WHERE content_type = $1 AND content_id = $2
ORDER BY created_at DESC
`

type GetReportsByContentParams struct {
	ContentType string    `json:"content_type"`
	ContentID   uuid.UUID `json:"content_id"`
}

func (q *Queries) GetReportsByContent(ctx context.Context, arg GetReportsByContentParams) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, getReportsByContent, arg.ContentType, arg.ContentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.ReporterID,
			&i.ContentType,
			&i.ContentID,
			&i.Reason,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ModerationNotes,
			&i.ActionsTaken,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpaceStats = `-- name: GetSpaceStats :one
SELECT
    s.name,
    s.slug,
    (SELECT COUNT(*) FROM users u5 WHERE u5.space_id = s.id AND u5.status = 'active') as user_count,
    (SELECT COUNT(*) FROM posts p3 WHERE p3.space_id = s.id AND p3.status = 'active') as post_count,
    (SELECT COUNT(*) FROM communities c3 WHERE c3.space_id = s.id) as community_count,
    (SELECT COUNT(*) FROM groups g3 WHERE g3.space_id = s.id AND g3.status = 'active') as group_count,
    (SELECT created_at FROM users u6 WHERE u6.space_id = s.id ORDER BY u6.created_at ASC LIMIT 1) as first_user_date
FROM spaces s
WHERE s.id = $1
`

type GetSpaceStatsRow struct {
	Name           string       `json:"name"`
	Slug           string       `json:"slug"`
	UserCount      int64        `json:"user_count"`
	PostCount      int64        `json:"post_count"`
	CommunityCount int64        `json:"community_count"`
	GroupCount     int64        `json:"group_count"`
	FirstUserDate  sql.NullTime `json:"first_user_date"`
}

func (q *Queries) GetSpaceStats(ctx context.Context, id uuid.UUID) (GetSpaceStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSpaceStats, id)
	var i GetSpaceStatsRow
	err := row.Scan(
		&i.Name,
		&i.Slug,
		&i.UserCount,
		&i.PostCount,
		&i.CommunityCount,
		&i.GroupCount,
		&i.FirstUserDate,
	)
	return i, err
}

const getSystemMetrics = `-- name: GetSystemMetrics :one

SELECT
    (SELECT COUNT(*) FROM users u2 WHERE u2.space_id = $1 AND u2.status = 'active') as total_users,
    (SELECT COUNT(*) FROM users u3 WHERE u3.space_id = $1 AND u3.updated_at >= NOW() - INTERVAL '1 day') as active_users,
    (SELECT COUNT(*) FROM users u4 WHERE u4.space_id = $1 AND u4.created_at >= CURRENT_DATE) as new_users_today,
    (SELECT COUNT(*) FROM posts p2 WHERE p2.space_id = $1 AND p2.created_at >= CURRENT_DATE) as daily_posts,
    (SELECT COUNT(*) FROM groups g2 WHERE g2.space_id = $1) as total_groups,
    (SELECT COUNT(*) FROM communities c2 WHERE c2.space_id = $1) as total_communities,
    (SELECT COUNT(*) FROM events e2 WHERE e2.space_id = $1 AND e2.status = 'published') as total_events,
    (SELECT COUNT(*) FROM tutoring_sessions ts2 WHERE ts2.space_id = $1 AND ts2.status = 'pending') as pending_tutoring_sessions,
    (SELECT COUNT(*) FROM mentoring_sessions ms2 WHERE ms2.space_id = $1 AND ms2.status = 'pending') as pending_mentoring_sessions,
    (SELECT COUNT(*) FROM reports r2 WHERE r2.space_id = $1 AND r2.status = 'pending') as pending_reports,
    (SELECT COUNT(*) FROM tutor_applications ta2 WHERE ta2.space_id = $1 AND ta2.status = 'pending') as pending_tutor_applications,
    (SELECT COUNT(*) FROM mentor_applications ma2 WHERE ma2.space_id = $1 AND ma2.status = 'pending') as pending_mentor_applications
`

type GetSystemMetricsRow struct {
	TotalUsers                int64 `json:"total_users"`
	ActiveUsers               int64 `json:"active_users"`
	NewUsersToday             int64 `json:"new_users_today"`
	DailyPosts                int64 `json:"daily_posts"`
	TotalGroups               int64 `json:"total_groups"`
	TotalCommunities          int64 `json:"total_communities"`
	TotalEvents               int64 `json:"total_events"`
	PendingTutoringSessions   int64 `json:"pending_tutoring_sessions"`
	PendingMentoringSessions  int64 `json:"pending_mentoring_sessions"`
	PendingReports            int64 `json:"pending_reports"`
	PendingTutorApplications  int64 `json:"pending_tutor_applications"`
	PendingMentorApplications int64 `json:"pending_mentor_applications"`
}

// Analytics and Reporting Queries
func (q *Queries) GetSystemMetrics(ctx context.Context, spaceID uuid.UUID) (GetSystemMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getSystemMetrics, spaceID)
	var i GetSystemMetricsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.ActiveUsers,
		&i.NewUsersToday,
		&i.DailyPosts,
		&i.TotalGroups,
		&i.TotalCommunities,
		&i.TotalEvents,
		&i.PendingTutoringSessions,
		&i.PendingMentoringSessions,
		&i.PendingReports,
		&i.PendingTutorApplications,
		&i.PendingMentorApplications,
	)
	return i, err
}

const getTopCommunities = `-- name: GetTopCommunities :many
SELECT 
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    (c.member_count + c.post_count) as engagement_score
FROM communities c
WHERE c.space_id = $1
ORDER BY engagement_score DESC
LIMIT 10
`

type GetTopCommunitiesRow struct {
	ID              uuid.UUID             `json:"id"`
	SpaceID         uuid.UUID             `json:"space_id"`
	Name            string                `json:"name"`
	Description     sql.NullString        `json:"description"`
	Category        string                `json:"category"`
	CoverImage      sql.NullString        `json:"cover_image"`
	MemberCount     sql.NullInt32         `json:"member_count"`
	Status          sql.NullString        `json:"status"`
	PostCount       sql.NullInt32         `json:"post_count"`
	IsPublic        sql.NullBool          `json:"is_public"`
	CreatedBy       uuid.NullUUID         `json:"created_by"`
	Settings        pqtype.NullRawMessage `json:"settings"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
	EngagementScore int32                 `json:"engagement_score"`
}

func (q *Queries) GetTopCommunities(ctx context.Context, spaceID uuid.UUID) ([]GetTopCommunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCommunities, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopCommunitiesRow{}
	for rows.Next() {
		var i GetTopCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.CoverImage,
			&i.MemberCount,
			&i.Status,
			&i.PostCount,
			&i.IsPublic,
			&i.CreatedBy,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopGroups = `-- name: GetTopGroups :many
SELECT 
    g.id, g.space_id, g.community_id, g.name, g.description, g.category, g.group_type, g.avatar, g.banner, g.member_count, g.post_count, g.status, g.visibility, g.allow_invites, g.allow_member_posts, g.created_by, g.tags, g.settings, g.created_at, g.updated_at,
    (g.member_count + g.post_count) as engagement_score
FROM groups g
WHERE g.space_id = $1 AND g.status = 'active'
ORDER BY engagement_score DESC
LIMIT 10
`

type GetTopGroupsRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	CommunityID      uuid.NullUUID         `json:"community_id"`
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Category         string                `json:"category"`
	GroupType        string                `json:"group_type"`
	Avatar           sql.NullString        `json:"avatar"`
	Banner           sql.NullString        `json:"banner"`
	MemberCount      sql.NullInt32         `json:"member_count"`
	PostCount        sql.NullInt32         `json:"post_count"`
	Status           sql.NullString        `json:"status"`
	Visibility       sql.NullString        `json:"visibility"`
	AllowInvites     sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts sql.NullBool          `json:"allow_member_posts"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
	Tags             []string              `json:"tags"`
	Settings         pqtype.NullRawMessage `json:"settings"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	EngagementScore  int32                 `json:"engagement_score"`
}

func (q *Queries) GetTopGroups(ctx context.Context, spaceID uuid.UUID) ([]GetTopGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopGroups, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopGroupsRow{}
	for rows.Next() {
		var i GetTopGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPosts = `-- name: GetTopPosts :many
SELECT 
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    u.username,
    u.full_name,
    (p.likes_count + p.comments_count + p.views_count) as engagement_score
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.space_id = $1 
  AND p.created_at >= NOW() - INTERVAL '7 days'
  AND p.status = 'active'
ORDER BY engagement_score DESC
LIMIT 10
`

type GetTopPostsRow struct {
	ID              uuid.UUID             `json:"id"`
	AuthorID        uuid.UUID             `json:"author_id"`
	SpaceID         uuid.UUID             `json:"space_id"`
	CommunityID     uuid.NullUUID         `json:"community_id"`
	GroupID         uuid.NullUUID         `json:"group_id"`
	ParentPostID    uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID    uuid.NullUUID         `json:"quoted_post_id"`
	Content         string                `json:"content"`
	Media           pqtype.NullRawMessage `json:"media"`
	Tags            []string              `json:"tags"`
	LikesCount      sql.NullInt32         `json:"likes_count"`
	CommentsCount   sql.NullInt32         `json:"comments_count"`
	RepostsCount    sql.NullInt32         `json:"reposts_count"`
	QuotesCount     sql.NullInt32         `json:"quotes_count"`
	ViewsCount      sql.NullInt32         `json:"views_count"`
	IsPinned        sql.NullBool          `json:"is_pinned"`
	Visibility      sql.NullString        `json:"visibility"`
	Status          sql.NullString        `json:"status"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
	Username        string                `json:"username"`
	FullName        string                `json:"full_name"`
	EngagementScore int32                 `json:"engagement_score"`
}

func (q *Queries) GetTopPosts(ctx context.Context, spaceID uuid.UUID) ([]GetTopPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPosts, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPostsRow{}
	for rows.Next() {
		var i GetTopPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTutoringStats = `-- name: GetTutoringStats :one
SELECT
    COUNT(*) as total_sessions,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_sessions,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_sessions,
    COALESCE(AVG(rating), 0) as average_rating,
    COUNT(*) FILTER (WHERE rating IS NOT NULL) as rated_sessions
FROM tutoring_sessions
WHERE space_id = $1
`

type GetTutoringStatsRow struct {
	TotalSessions     int64       `json:"total_sessions"`
	CompletedSessions int64       `json:"completed_sessions"`
	PendingSessions   int64       `json:"pending_sessions"`
	AverageRating     interface{} `json:"average_rating"`
	RatedSessions     int64       `json:"rated_sessions"`
}

func (q *Queries) GetTutoringStats(ctx context.Context, spaceID uuid.UUID) (GetTutoringStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTutoringStats, spaceID)
	var i GetTutoringStatsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.CompletedSessions,
		&i.PendingSessions,
		&i.AverageRating,
		&i.RatedSessions,
	)
	return i, err
}

const getUserActivityStats = `-- name: GetUserActivityStats :many

SELECT
    'session_activity' as action,
    COUNT(*) as count,
    DATE(us.last_activity) as date
FROM user_sessions us
WHERE us.space_id = $1 AND us.last_activity >= NOW() - INTERVAL '7 days'
GROUP BY DATE(us.last_activity)
ORDER BY date DESC, count DESC
`

type GetUserActivityStatsRow struct {
	Action string    `json:"action"`
	Count  int64     `json:"count"`
	Date   time.Time `json:"date"`
}

// Note: User activities are now tracked via user_sessions table
func (q *Queries) GetUserActivityStats(ctx context.Context, spaceID uuid.UUID) ([]GetUserActivityStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserActivityStats, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserActivityStatsRow{}
	for rows.Next() {
		var i GetUserActivityStatsRow
		if err := rows.Scan(&i.Action, &i.Count, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEngagementRanking = `-- name: GetUserEngagementRanking :many
SELECT 
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    COUNT(p.id) as post_count,
    COUNT(DISTINCT f1.follower_id) as followers_count,
    COUNT(DISTINCT f2.following_id) as following_count,
    (COUNT(p.id) + COUNT(DISTINCT f1.follower_id) * 2) as engagement_score
FROM users u
LEFT JOIN posts p ON u.id = p.author_id AND p.status = 'active'
LEFT JOIN follows f1 ON u.id = f1.following_id
LEFT JOIN follows f2 ON u.id = f2.follower_id
WHERE u.space_id = $1 AND u.status = 'active'
GROUP BY u.id
ORDER BY engagement_score DESC
LIMIT 20
`

type GetUserEngagementRankingRow struct {
	ID              uuid.UUID      `json:"id"`
	Username        string         `json:"username"`
	FullName        string         `json:"full_name"`
	Avatar          sql.NullString `json:"avatar"`
	PostCount       int64          `json:"post_count"`
	FollowersCount  int64          `json:"followers_count"`
	FollowingCount  int64          `json:"following_count"`
	EngagementScore int32          `json:"engagement_score"`
}

func (q *Queries) GetUserEngagementRanking(ctx context.Context, spaceID uuid.UUID) ([]GetUserEngagementRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEngagementRanking, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserEngagementRankingRow{}
	for rows.Next() {
		var i GetUserEngagementRankingRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.PostCount,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrowth = `-- name: GetUserGrowth :many
SELECT 
    DATE(created_at) as date,
    COUNT(*) as new_users
FROM users 
WHERE space_id = $1 AND created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date
`

type GetUserGrowthRow struct {
	Date     time.Time `json:"date"`
	NewUsers int64     `json:"new_users"`
}

func (q *Queries) GetUserGrowth(ctx context.Context, spaceID uuid.UUID) ([]GetUserGrowthRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserGrowth, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrowthRow{}
	for rows.Next() {
		var i GetUserGrowthRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReport = `-- name: UpdateReport :one
UPDATE reports 
SET 
    status = $1,
    reviewed_by = $2,
    reviewed_at = NOW(),
    moderation_notes = $3,
    actions_taken = $4,
    updated_at = NOW()
WHERE id = $5
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type UpdateReportParams struct {
	Status          sql.NullString        `json:"status"`
	ReviewedBy      uuid.NullUUID         `json:"reviewed_by"`
	ModerationNotes sql.NullString        `json:"moderation_notes"`
	ActionsTaken    pqtype.NullRawMessage `json:"actions_taken"`
	ID              uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateReport(ctx context.Context, arg UpdateReportParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, updateReport,
		arg.Status,
		arg.ReviewedBy,
		arg.ModerationNotes,
		arg.ActionsTaken,
		arg.ID,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
