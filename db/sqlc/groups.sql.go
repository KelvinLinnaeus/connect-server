// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const addGroupAdmin = `-- name: AddGroupAdmin :one
INSERT INTO group_members (group_id, user_id, permissions, role)
VALUES ($1, $2, $3, 'admin')
ON CONFLICT (group_id, user_id) 
DO UPDATE SET permissions = $4, assigned_at = NOW()
RETURNING id, group_id, user_id, role, joined_at, invited_by, permissions
`

type AddGroupAdminParams struct {
	GroupID       uuid.UUID `json:"group_id"`
	UserID        uuid.UUID `json:"user_id"`
	Permissions   []string  `json:"permissions"`
	Permissions_2 []string  `json:"permissions_2"`
}

func (q *Queries) AddGroupAdmin(ctx context.Context, arg AddGroupAdminParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, addGroupAdmin,
		arg.GroupID,
		arg.UserID,
		pq.Array(arg.Permissions),
		pq.Array(arg.Permissions_2),
	)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.InvitedBy,
		pq.Array(&i.Permissions),
	)
	return i, err
}

const addGroupModerator = `-- name: AddGroupModerator :one
INSERT INTO group_members (group_id, user_id, permissions, role)
VALUES ($1, $2, $3, 'moderator')
ON CONFLICT (group_id, user_id) 
DO UPDATE SET permissions = $4, assigned_at = NOW()
RETURNING id, group_id, user_id, role, joined_at, invited_by, permissions
`

type AddGroupModeratorParams struct {
	GroupID       uuid.UUID `json:"group_id"`
	UserID        uuid.UUID `json:"user_id"`
	Permissions   []string  `json:"permissions"`
	Permissions_2 []string  `json:"permissions_2"`
}

func (q *Queries) AddGroupModerator(ctx context.Context, arg AddGroupModeratorParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, addGroupModerator,
		arg.GroupID,
		arg.UserID,
		pq.Array(arg.Permissions),
		pq.Array(arg.Permissions_2),
	)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.InvitedBy,
		pq.Array(&i.Permissions),
	)
	return i, err
}

const applyForProjectRole = `-- name: ApplyForProjectRole :one
INSERT INTO group_applications (role_id, user_id, message)
VALUES ($1, $2, $3)
ON CONFLICT (role_id, user_id) 
DO UPDATE SET message = $3, applied_at = NOW()
RETURNING id, role_id, user_id, message, status, applied_at, reviewed_at, reviewed_by, review_notes
`

type ApplyForProjectRoleParams struct {
	RoleID  uuid.UUID      `json:"role_id"`
	UserID  uuid.UUID      `json:"user_id"`
	Message sql.NullString `json:"message"`
}

func (q *Queries) ApplyForProjectRole(ctx context.Context, arg ApplyForProjectRoleParams) (GroupApplication, error) {
	row := q.db.QueryRowContext(ctx, applyForProjectRole, arg.RoleID, arg.UserID, arg.Message)
	var i GroupApplication
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.UserID,
		&i.Message,
		&i.Status,
		&i.AppliedAt,
		&i.ReviewedAt,
		&i.ReviewedBy,
		&i.ReviewNotes,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one

INSERT INTO groups (
    space_id, community_id, name, description, category, group_type,
    avatar, banner, allow_invites, allow_member_posts,
     created_by, tags, settings
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, space_id, community_id, name, description, category, group_type, avatar, banner, member_count, post_count, status, visibility, allow_invites, allow_member_posts, created_by, tags, settings, created_at, updated_at
`

type CreateGroupParams struct {
	SpaceID          uuid.UUID             `json:"space_id"`
	CommunityID      uuid.NullUUID         `json:"community_id"`
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Category         string                `json:"category"`
	GroupType        string                `json:"group_type"`
	Avatar           sql.NullString        `json:"avatar"`
	Banner           sql.NullString        `json:"banner"`
	AllowInvites     sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts sql.NullBool          `json:"allow_member_posts"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
	Tags             []string              `json:"tags"`
	Settings         pqtype.NullRawMessage `json:"settings"`
}

// Groups Management Queries
func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup,
		arg.SpaceID,
		arg.CommunityID,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.GroupType,
		arg.Avatar,
		arg.Banner,
		arg.AllowInvites,
		arg.AllowMemberPosts,
		arg.CreatedBy,
		pq.Array(arg.Tags),
		arg.Settings,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.CommunityID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.GroupType,
		&i.Avatar,
		&i.Banner,
		&i.MemberCount,
		&i.PostCount,
		&i.Status,
		&i.Visibility,
		&i.AllowInvites,
		&i.AllowMemberPosts,
		&i.CreatedBy,
		pq.Array(&i.Tags),
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectRole = `-- name: CreateProjectRole :one
INSERT INTO group_roles (group_id, name, description, slots_total, requirements, skills_required)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, group_id, name, description, slots_total, slots_filled, requirements, skills_required, created_at, updated_at
`

type CreateProjectRoleParams struct {
	GroupID        uuid.UUID      `json:"group_id"`
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	SlotsTotal     int32          `json:"slots_total"`
	Requirements   sql.NullString `json:"requirements"`
	SkillsRequired []string       `json:"skills_required"`
}

func (q *Queries) CreateProjectRole(ctx context.Context, arg CreateProjectRoleParams) (GroupRole, error) {
	row := q.db.QueryRowContext(ctx, createProjectRole,
		arg.GroupID,
		arg.Name,
		arg.Description,
		arg.SlotsTotal,
		arg.Requirements,
		pq.Array(arg.SkillsRequired),
	)
	var i GroupRole
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Description,
		&i.SlotsTotal,
		&i.SlotsFilled,
		&i.Requirements,
		pq.Array(&i.SkillsRequired),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT 
    g.id, g.space_id, g.community_id, g.name, g.description, g.category, g.group_type, g.avatar, g.banner, g.member_count, g.post_count, g.status, g.visibility, g.allow_invites, g.allow_member_posts, g.created_by, g.tags, g.settings, g.created_at, g.updated_at,
    c.name as community_name,
    u.username as created_by_username,
    u.full_name as created_by_full_name,
    EXISTS(SELECT 1 FROM group_members gm2 WHERE gm2.group_id = g.id AND gm2.user_id = $1) as is_member,
    gm.role as user_role,
    (SELECT COUNT(*) FROM group_members gm3 WHERE gm3.group_id = g.id) as actual_member_count,
    (SELECT COUNT(*) FROM posts WHERE group_id = g.id AND status = 'active') as actual_post_count
FROM groups g
LEFT JOIN communities c ON g.community_id = c.id
JOIN users u ON g.created_by = u.id
LEFT JOIN group_members gm ON g.id = gm.group_id AND gm.user_id = $1
WHERE g.id = $2 AND g.status = 'active'
`

type GetGroupByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

type GetGroupByIDRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	CommunityID       uuid.NullUUID         `json:"community_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	GroupType         string                `json:"group_type"`
	Avatar            sql.NullString        `json:"avatar"`
	Banner            sql.NullString        `json:"banner"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	PostCount         sql.NullInt32         `json:"post_count"`
	Status            sql.NullString        `json:"status"`
	Visibility        sql.NullString        `json:"visibility"`
	AllowInvites      sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts  sql.NullBool          `json:"allow_member_posts"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Tags              []string              `json:"tags"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CommunityName     sql.NullString        `json:"community_name"`
	CreatedByUsername string                `json:"created_by_username"`
	CreatedByFullName string                `json:"created_by_full_name"`
	IsMember          bool                  `json:"is_member"`
	UserRole          sql.NullString        `json:"user_role"`
	ActualMemberCount int64                 `json:"actual_member_count"`
	ActualPostCount   int64                 `json:"actual_post_count"`
}

func (q *Queries) GetGroupByID(ctx context.Context, arg GetGroupByIDParams) (GetGroupByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, arg.UserID, arg.ID)
	var i GetGroupByIDRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.CommunityID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.GroupType,
		&i.Avatar,
		&i.Banner,
		&i.MemberCount,
		&i.PostCount,
		&i.Status,
		&i.Visibility,
		&i.AllowInvites,
		&i.AllowMemberPosts,
		&i.CreatedBy,
		pq.Array(&i.Tags),
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommunityName,
		&i.CreatedByUsername,
		&i.CreatedByFullName,
		&i.IsMember,
		&i.UserRole,
		&i.ActualMemberCount,
		&i.ActualPostCount,
	)
	return i, err
}

const getGroupJoinRequests = `-- name: GetGroupJoinRequests :many
SELECT
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    u.level,
    u.department,
    u.verified,
    gm.role,
    gm.joined_at,
    gm.permissions
FROM group_members gm
JOIN users u ON gm.user_id = u.id
WHERE gm.group_id = $1 AND u.status = 'active'
ORDER BY
    gm.joined_at
`

type GetGroupJoinRequestsRow struct {
	ID          uuid.UUID      `json:"id"`
	Username    string         `json:"username"`
	FullName    string         `json:"full_name"`
	Avatar      sql.NullString `json:"avatar"`
	Level       sql.NullString `json:"level"`
	Department  sql.NullString `json:"department"`
	Verified    sql.NullBool   `json:"verified"`
	Role        string         `json:"role"`
	JoinedAt    sql.NullTime   `json:"joined_at"`
	Permissions []string       `json:"permissions"`
}

func (q *Queries) GetGroupJoinRequests(ctx context.Context, groupID uuid.UUID) ([]GetGroupJoinRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupJoinRequests, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupJoinRequestsRow{}
	for rows.Next() {
		var i GetGroupJoinRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Level,
			&i.Department,
			&i.Verified,
			&i.Role,
			&i.JoinedAt,
			pq.Array(&i.Permissions),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsBySpaceID = `-- name: GetGroupsBySpaceID :many

SELECT id, space_id, community_id, name, description, category, group_type, avatar, banner, member_count, post_count, status, visibility, allow_invites, allow_member_posts, created_by, tags, settings, created_at, updated_at FROM groups
WHERE space_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetGroupsBySpaceIDParams struct {
	SpaceID uuid.UUID `json:"space_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

// Admin Group Management Queries
func (q *Queries) GetGroupsBySpaceID(ctx context.Context, arg GetGroupsBySpaceIDParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsBySpaceID, arg.SpaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByStatus = `-- name: GetGroupsByStatus :many
SELECT id, space_id, community_id, name, description, category, group_type, avatar, banner, member_count, post_count, status, visibility, allow_invites, allow_member_posts, created_by, tags, settings, created_at, updated_at FROM groups
WHERE space_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetGroupsByStatusParams struct {
	SpaceID uuid.UUID      `json:"space_id"`
	Status  sql.NullString `json:"status"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) GetGroupsByStatus(ctx context.Context, arg GetGroupsByStatusParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByStatus,
		arg.SpaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRoles = `-- name: GetProjectRoles :many
SELECT id, group_id, name, description, slots_total, slots_filled, requirements, skills_required, created_at, updated_at FROM group_roles WHERE group_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetProjectRoles(ctx context.Context, groupID uuid.UUID) ([]GroupRole, error) {
	rows, err := q.db.QueryContext(ctx, getProjectRoles, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupRole{}
	for rows.Next() {
		var i GroupRole
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Description,
			&i.SlotsTotal,
			&i.SlotsFilled,
			&i.Requirements,
			pq.Array(&i.SkillsRequired),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleApplications = `-- name: GetRoleApplications :many
SELECT
    ra.id, ra.role_id, ra.user_id, ra.message, ra.status, ra.applied_at, ra.reviewed_at, ra.reviewed_by, ra.review_notes,
    u.username,
    u.full_name,
    u.avatar,
    pr.name as role_name
FROM group_applications ra
JOIN users u ON ra.user_id = u.id
JOIN group_roles pr ON ra.role_id = pr.id
WHERE pr.group_id = $1 AND ra.status = 'pending'
ORDER BY ra.applied_at DESC
`

type GetRoleApplicationsRow struct {
	ID          uuid.UUID      `json:"id"`
	RoleID      uuid.UUID      `json:"role_id"`
	UserID      uuid.UUID      `json:"user_id"`
	Message     sql.NullString `json:"message"`
	Status      sql.NullString `json:"status"`
	AppliedAt   sql.NullTime   `json:"applied_at"`
	ReviewedAt  sql.NullTime   `json:"reviewed_at"`
	ReviewedBy  uuid.NullUUID  `json:"reviewed_by"`
	ReviewNotes sql.NullString `json:"review_notes"`
	Username    string         `json:"username"`
	FullName    string         `json:"full_name"`
	Avatar      sql.NullString `json:"avatar"`
	RoleName    string         `json:"role_name"`
}

func (q *Queries) GetRoleApplications(ctx context.Context, groupID uuid.UUID) ([]GetRoleApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoleApplications, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoleApplicationsRow{}
	for rows.Next() {
		var i GetRoleApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.UserID,
			&i.Message,
			&i.Status,
			&i.AppliedAt,
			&i.ReviewedAt,
			&i.ReviewedBy,
			&i.ReviewNotes,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGroups = `-- name: GetUserGroups :many
SELECT 
    g.id, g.space_id, g.community_id, g.name, g.description, g.category, g.group_type, g.avatar, g.banner, g.member_count, g.post_count, g.status, g.visibility, g.allow_invites, g.allow_member_posts, g.created_by, g.tags, g.settings, g.created_at, g.updated_at,
    c.name as community_name,
    gm.role as user_role,
    gm.joined_at
FROM groups g
LEFT JOIN communities c ON g.community_id = c.id
JOIN group_members gm ON g.id = gm.group_id
WHERE gm.user_id = $1 AND g.space_id = $2 AND g.status = 'active'
ORDER BY gm.joined_at DESC
`

type GetUserGroupsParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
}

type GetUserGroupsRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	CommunityID      uuid.NullUUID         `json:"community_id"`
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Category         string                `json:"category"`
	GroupType        string                `json:"group_type"`
	Avatar           sql.NullString        `json:"avatar"`
	Banner           sql.NullString        `json:"banner"`
	MemberCount      sql.NullInt32         `json:"member_count"`
	PostCount        sql.NullInt32         `json:"post_count"`
	Status           sql.NullString        `json:"status"`
	Visibility       sql.NullString        `json:"visibility"`
	AllowInvites     sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts sql.NullBool          `json:"allow_member_posts"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
	Tags             []string              `json:"tags"`
	Settings         pqtype.NullRawMessage `json:"settings"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	CommunityName    sql.NullString        `json:"community_name"`
	UserRole         string                `json:"user_role"`
	JoinedAt         sql.NullTime          `json:"joined_at"`
}

func (q *Queries) GetUserGroups(ctx context.Context, arg GetUserGroupsParams) ([]GetUserGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserGroups, arg.UserID, arg.SpaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGroupsRow{}
	for rows.Next() {
		var i GetUserGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommunityName,
			&i.UserRole,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isGroupAdmin = `-- name: IsGroupAdmin :one
SELECT EXISTS(
    SELECT 1 FROM group_members ga 
    WHERE ga.group_id = $1 AND ga.user_id = $2 AND role 'admin'
) as is_admin
`

type IsGroupAdminParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) IsGroupAdmin(ctx context.Context, arg IsGroupAdminParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isGroupAdmin, arg.GroupID, arg.UserID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isGroupModerator = `-- name: IsGroupModerator :one
SELECT EXISTS(
    SELECT 1 FROM group_members gm 
    WHERE gm.group_id = $1 AND gm.user_id = $2 AND role = 'moderator'
) as is_moderator
`

type IsGroupModeratorParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) IsGroupModerator(ctx context.Context, arg IsGroupModeratorParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isGroupModerator, arg.GroupID, arg.UserID)
	var is_moderator bool
	err := row.Scan(&is_moderator)
	return is_moderator, err
}

const joinGroup = `-- name: JoinGroup :one
INSERT INTO group_members (group_id, user_id, role, invited_by)
VALUES ($1, $2, 'member', $3)
ON CONFLICT (group_id, user_id) 
DO UPDATE SET role = 'member', joined_at = NOW()
RETURNING id, group_id, user_id, role, joined_at, invited_by, permissions
`

type JoinGroupParams struct {
	GroupID   uuid.UUID     `json:"group_id"`
	UserID    uuid.UUID     `json:"user_id"`
	InvitedBy uuid.NullUUID `json:"invited_by"`
}

func (q *Queries) JoinGroup(ctx context.Context, arg JoinGroupParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, joinGroup, arg.GroupID, arg.UserID, arg.InvitedBy)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.InvitedBy,
		pq.Array(&i.Permissions),
	)
	return i, err
}

const leaveGroup = `-- name: LeaveGroup :exec
DELETE FROM group_members WHERE group_id = $1 AND user_id = $2
`

type LeaveGroupParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) LeaveGroup(ctx context.Context, arg LeaveGroupParams) error {
	_, err := q.db.ExecContext(ctx, leaveGroup, arg.GroupID, arg.UserID)
	return err
}

const listGroups = `-- name: ListGroups :many
SELECT 
    g.id, g.space_id, g.community_id, g.name, g.description, g.category, g.group_type, g.avatar, g.banner, g.member_count, g.post_count, g.status, g.visibility, g.allow_invites, g.allow_member_posts, g.created_by, g.tags, g.settings, g.created_at, g.updated_at,
    c.name as community_name,
    EXISTS(SELECT 1 FROM group_members gm2 WHERE gm2.group_id = g.id AND gm2.user_id = $1) as is_member,
    gm.role as user_role,
    (SELECT COUNT(*) FROM group_members gm3 WHERE gm3.group_id = g.id) as actual_member_count
FROM groups g
LEFT JOIN communities c ON g.community_id = c.id
LEFT JOIN group_members gm ON g.id = gm.group_id AND gm.user_id = $1
WHERE g.space_id = $2 AND g.status = 'active'
  AND (g.visibility = 'public' OR EXISTS(SELECT 1 FROM group_members gm4 WHERE gm4.group_id = g.id AND gm4.user_id = $1))
ORDER BY 
    CASE WHEN $3 = 'members' THEN g.member_count END DESC,
    CASE WHEN $3 = 'recent' THEN g.created_at END DESC,
    g.name ASC
LIMIT $4 OFFSET $5
`

type ListGroupsParams struct {
	UserID  uuid.UUID   `json:"user_id"`
	SpaceID uuid.UUID   `json:"space_id"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListGroupsRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	CommunityID       uuid.NullUUID         `json:"community_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	GroupType         string                `json:"group_type"`
	Avatar            sql.NullString        `json:"avatar"`
	Banner            sql.NullString        `json:"banner"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	PostCount         sql.NullInt32         `json:"post_count"`
	Status            sql.NullString        `json:"status"`
	Visibility        sql.NullString        `json:"visibility"`
	AllowInvites      sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts  sql.NullBool          `json:"allow_member_posts"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Tags              []string              `json:"tags"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CommunityName     sql.NullString        `json:"community_name"`
	IsMember          bool                  `json:"is_member"`
	UserRole          sql.NullString        `json:"user_role"`
	ActualMemberCount int64                 `json:"actual_member_count"`
}

func (q *Queries) ListGroups(ctx context.Context, arg ListGroupsParams) ([]ListGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroups,
		arg.UserID,
		arg.SpaceID,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGroupsRow{}
	for rows.Next() {
		var i ListGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommunityName,
			&i.IsMember,
			&i.UserRole,
			&i.ActualMemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeGroupAdmin = `-- name: RemoveGroupAdmin :exec
DELETE FROM group_members WHERE group_id = $1 AND user_id = $2 AND role='admin'
`

type RemoveGroupAdminParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveGroupAdmin(ctx context.Context, arg RemoveGroupAdminParams) error {
	_, err := q.db.ExecContext(ctx, removeGroupAdmin, arg.GroupID, arg.UserID)
	return err
}

const removeGroupModerator = `-- name: RemoveGroupModerator :exec
DELETE FROM group_members WHERE group_id = $1 AND user_id = $2 AND role 'moderator'
`

type RemoveGroupModeratorParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveGroupModerator(ctx context.Context, arg RemoveGroupModeratorParams) error {
	_, err := q.db.ExecContext(ctx, removeGroupModerator, arg.GroupID, arg.UserID)
	return err
}

const searchGroups = `-- name: SearchGroups :many
SELECT 
    g.id, g.space_id, g.community_id, g.name, g.description, g.category, g.group_type, g.avatar, g.banner, g.member_count, g.post_count, g.status, g.visibility, g.allow_invites, g.allow_member_posts, g.created_by, g.tags, g.settings, g.created_at, g.updated_at,
    c.name as community_name,
    EXISTS(SELECT 1 FROM group_members gm2 WHERE gm2.group_id = g.id AND gm2.user_id = $1) as is_member,
    (SELECT COUNT(*) FROM group_members gm3 WHERE gm3.group_id = g.id) as actual_member_count
FROM groups g
LEFT JOIN communities c ON g.community_id = c.id
WHERE g.space_id = $2
  AND g.status = 'active'
  AND (g.name ILIKE $3 OR g.description ILIKE $3 OR g.tags @> ARRAY[$3]::text[])
  AND (g.visibility = 'public' OR EXISTS(SELECT 1 FROM group_members gm4 WHERE gm4.group_id = g.id AND gm4.user_id = $1))
ORDER BY g.member_count DESC
LIMIT 50
`

type SearchGroupsParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
	Name    string    `json:"name"`
}

type SearchGroupsRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	CommunityID       uuid.NullUUID         `json:"community_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	GroupType         string                `json:"group_type"`
	Avatar            sql.NullString        `json:"avatar"`
	Banner            sql.NullString        `json:"banner"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	PostCount         sql.NullInt32         `json:"post_count"`
	Status            sql.NullString        `json:"status"`
	Visibility        sql.NullString        `json:"visibility"`
	AllowInvites      sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts  sql.NullBool          `json:"allow_member_posts"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Tags              []string              `json:"tags"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CommunityName     sql.NullString        `json:"community_name"`
	IsMember          bool                  `json:"is_member"`
	ActualMemberCount int64                 `json:"actual_member_count"`
}

func (q *Queries) SearchGroups(ctx context.Context, arg SearchGroupsParams) ([]SearchGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGroups, arg.UserID, arg.SpaceID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchGroupsRow{}
	for rows.Next() {
		var i SearchGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.CommunityID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.GroupType,
			&i.Avatar,
			&i.Banner,
			&i.MemberCount,
			&i.PostCount,
			&i.Status,
			&i.Visibility,
			&i.AllowInvites,
			&i.AllowMemberPosts,
			&i.CreatedBy,
			pq.Array(&i.Tags),
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommunityName,
			&i.IsMember,
			&i.ActualMemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups 
SET 
    name = $1,
    description = $2,
    category = $3,
    avatar = $4,
    banner = $5,
    allow_invites = $6,
    allow_member_posts = $7,
    tags = $8,
    settings = $9,
    updated_at = NOW()
WHERE id = $10
RETURNING id, space_id, community_id, name, description, category, group_type, avatar, banner, member_count, post_count, status, visibility, allow_invites, allow_member_posts, created_by, tags, settings, created_at, updated_at
`

type UpdateGroupParams struct {
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Category         string                `json:"category"`
	Avatar           sql.NullString        `json:"avatar"`
	Banner           sql.NullString        `json:"banner"`
	AllowInvites     sql.NullBool          `json:"allow_invites"`
	AllowMemberPosts sql.NullBool          `json:"allow_member_posts"`
	Tags             []string              `json:"tags"`
	Settings         pqtype.NullRawMessage `json:"settings"`
	ID               uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, updateGroup,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.Avatar,
		arg.Banner,
		arg.AllowInvites,
		arg.AllowMemberPosts,
		pq.Array(arg.Tags),
		arg.Settings,
		arg.ID,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.CommunityID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.GroupType,
		&i.Avatar,
		&i.Banner,
		&i.MemberCount,
		&i.PostCount,
		&i.Status,
		&i.Visibility,
		&i.AllowInvites,
		&i.AllowMemberPosts,
		&i.CreatedBy,
		pq.Array(&i.Tags),
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupMemberRole = `-- name: UpdateGroupMemberRole :exec
UPDATE group_members 
SET role = $1, permissions = $2 
WHERE group_id = $3 AND user_id = $4
`

type UpdateGroupMemberRoleParams struct {
	Role        string    `json:"role"`
	Permissions []string  `json:"permissions"`
	GroupID     uuid.UUID `json:"group_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateGroupMemberRole(ctx context.Context, arg UpdateGroupMemberRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupMemberRole,
		arg.Role,
		pq.Array(arg.Permissions),
		arg.GroupID,
		arg.UserID,
	)
	return err
}

const updateGroupStats = `-- name: UpdateGroupStats :exec
UPDATE groups 
SET 
    member_count = (SELECT COUNT(*) FROM group_members gm7 WHERE gm7.group_id = $1),
    post_count = (SELECT COUNT(*) FROM posts WHERE group_id = $1 AND status = 'active'),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupStats(ctx context.Context, groupID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateGroupStats, groupID)
	return err
}

const updateGroupStatus = `-- name: UpdateGroupStatus :exec
UPDATE groups
SET status = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateGroupStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateGroupStatus(ctx context.Context, arg UpdateGroupStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupStatus, arg.Status, arg.ID)
	return err
}
