// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: login_attempts.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const cleanupOldLoginAttempts = `-- name: CleanupOldLoginAttempts :exec
DELETE FROM login_attempts
WHERE attempted_at < $1
`

func (q *Queries) CleanupOldLoginAttempts(ctx context.Context, attemptedAt time.Time) error {
	_, err := q.db.ExecContext(ctx, cleanupOldLoginAttempts, attemptedAt)
	return err
}

const countRecentFailedLoginAttemptsByIP = `-- name: CountRecentFailedLoginAttemptsByIP :one
SELECT COUNT(*) FROM login_attempts
WHERE ip_address = $1
  AND attempt_result IN ('failed_password', 'failed_user_not_found')
  AND attempted_at > $2
`

type CountRecentFailedLoginAttemptsByIPParams struct {
	IpAddress   pqtype.Inet `json:"ip_address"`
	AttemptedAt time.Time   `json:"attempted_at"`
}

func (q *Queries) CountRecentFailedLoginAttemptsByIP(ctx context.Context, arg CountRecentFailedLoginAttemptsByIPParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentFailedLoginAttemptsByIP, arg.IpAddress, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentFailedLoginAttemptsByUsername = `-- name: CountRecentFailedLoginAttemptsByUsername :one
SELECT COUNT(*) FROM login_attempts
WHERE username = $1
  AND attempt_result IN ('failed_password', 'failed_user_not_found')
  AND attempted_at > $2
`

type CountRecentFailedLoginAttemptsByUsernameParams struct {
	Username    string    `json:"username"`
	AttemptedAt time.Time `json:"attempted_at"`
}

func (q *Queries) CountRecentFailedLoginAttemptsByUsername(ctx context.Context, arg CountRecentFailedLoginAttemptsByUsernameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentFailedLoginAttemptsByUsername, arg.Username, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLoginAttempt = `-- name: CreateLoginAttempt :one
INSERT INTO login_attempts (
    username,
    ip_address,
    user_agent,
    attempt_result,
    user_id,
    space_id,
    session_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, username, ip_address, user_agent, attempt_result, attempted_at, user_id, space_id, session_id
`

type CreateLoginAttemptParams struct {
	Username      string         `json:"username"`
	IpAddress     pqtype.Inet    `json:"ip_address"`
	UserAgent     sql.NullString `json:"user_agent"`
	AttemptResult string         `json:"attempt_result"`
	UserID        uuid.NullUUID  `json:"user_id"`
	SpaceID       uuid.NullUUID  `json:"space_id"`
	SessionID     uuid.NullUUID  `json:"session_id"`
}

func (q *Queries) CreateLoginAttempt(ctx context.Context, arg CreateLoginAttemptParams) (LoginAttempt, error) {
	row := q.db.QueryRowContext(ctx, createLoginAttempt,
		arg.Username,
		arg.IpAddress,
		arg.UserAgent,
		arg.AttemptResult,
		arg.UserID,
		arg.SpaceID,
		arg.SessionID,
	)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.IpAddress,
		&i.UserAgent,
		&i.AttemptResult,
		&i.AttemptedAt,
		&i.UserID,
		&i.SpaceID,
		&i.SessionID,
	)
	return i, err
}

const getLockedUsers = `-- name: GetLockedUsers :many
SELECT id, username, email, is_locked, locked_until, failed_login_attempts, last_failed_login
FROM users
WHERE is_locked = TRUE
ORDER BY locked_until DESC
`

type GetLockedUsersRow struct {
	ID                  uuid.UUID    `json:"id"`
	Username            string       `json:"username"`
	Email               string       `json:"email"`
	IsLocked            bool         `json:"is_locked"`
	LockedUntil         sql.NullTime `json:"locked_until"`
	FailedLoginAttempts int32        `json:"failed_login_attempts"`
	LastFailedLogin     sql.NullTime `json:"last_failed_login"`
}

func (q *Queries) GetLockedUsers(ctx context.Context) ([]GetLockedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getLockedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLockedUsersRow{}
	for rows.Next() {
		var i GetLockedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.IsLocked,
			&i.LockedUntil,
			&i.FailedLoginAttempts,
			&i.LastFailedLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsWithSessions = `-- name: GetLoginAttemptsWithSessions :many
SELECT
    la.id, la.username, la.ip_address, la.user_agent, la.attempt_result, la.attempted_at, la.user_id, la.space_id, la.session_id,
    us.refresh_token,
    us.is_blocked as session_is_blocked,
    us.expires_at as session_expires_at
FROM login_attempts la
LEFT JOIN user_sessions us ON la.session_id = us.id
WHERE la.user_id = $1
  AND la.attempted_at > $2
ORDER BY la.attempted_at DESC
LIMIT $3
`

type GetLoginAttemptsWithSessionsParams struct {
	UserID      uuid.NullUUID `json:"user_id"`
	AttemptedAt time.Time     `json:"attempted_at"`
	Limit       int32         `json:"limit"`
}

type GetLoginAttemptsWithSessionsRow struct {
	ID               uuid.UUID      `json:"id"`
	Username         string         `json:"username"`
	IpAddress        pqtype.Inet    `json:"ip_address"`
	UserAgent        sql.NullString `json:"user_agent"`
	AttemptResult    string         `json:"attempt_result"`
	AttemptedAt      time.Time      `json:"attempted_at"`
	UserID           uuid.NullUUID  `json:"user_id"`
	SpaceID          uuid.NullUUID  `json:"space_id"`
	SessionID        uuid.NullUUID  `json:"session_id"`
	RefreshToken     sql.NullString `json:"refresh_token"`
	SessionIsBlocked sql.NullBool   `json:"session_is_blocked"`
	SessionExpiresAt sql.NullTime   `json:"session_expires_at"`
}

func (q *Queries) GetLoginAttemptsWithSessions(ctx context.Context, arg GetLoginAttemptsWithSessionsParams) ([]GetLoginAttemptsWithSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLoginAttemptsWithSessions, arg.UserID, arg.AttemptedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLoginAttemptsWithSessionsRow{}
	for rows.Next() {
		var i GetLoginAttemptsWithSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptResult,
			&i.AttemptedAt,
			&i.UserID,
			&i.SpaceID,
			&i.SessionID,
			&i.RefreshToken,
			&i.SessionIsBlocked,
			&i.SessionExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedLoginAttemptsByIP = `-- name: GetRecentFailedLoginAttemptsByIP :many
SELECT id, username, ip_address, user_agent, attempt_result, attempted_at, user_id, space_id, session_id FROM login_attempts
WHERE ip_address = $1
  AND attempt_result IN ('failed_password', 'failed_user_not_found')
  AND attempted_at > $2
ORDER BY attempted_at DESC
`

type GetRecentFailedLoginAttemptsByIPParams struct {
	IpAddress   pqtype.Inet `json:"ip_address"`
	AttemptedAt time.Time   `json:"attempted_at"`
}

func (q *Queries) GetRecentFailedLoginAttemptsByIP(ctx context.Context, arg GetRecentFailedLoginAttemptsByIPParams) ([]LoginAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getRecentFailedLoginAttemptsByIP, arg.IpAddress, arg.AttemptedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptResult,
			&i.AttemptedAt,
			&i.UserID,
			&i.SpaceID,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedLoginAttemptsByUsername = `-- name: GetRecentFailedLoginAttemptsByUsername :many
SELECT id, username, ip_address, user_agent, attempt_result, attempted_at, user_id, space_id, session_id FROM login_attempts
WHERE username = $1
  AND attempt_result IN ('failed_password', 'failed_user_not_found')
  AND attempted_at > $2
ORDER BY attempted_at DESC
`

type GetRecentFailedLoginAttemptsByUsernameParams struct {
	Username    string    `json:"username"`
	AttemptedAt time.Time `json:"attempted_at"`
}

func (q *Queries) GetRecentFailedLoginAttemptsByUsername(ctx context.Context, arg GetRecentFailedLoginAttemptsByUsernameParams) ([]LoginAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getRecentFailedLoginAttemptsByUsername, arg.Username, arg.AttemptedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptResult,
			&i.AttemptedAt,
			&i.UserID,
			&i.SpaceID,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLoginAttemptsByIP = `-- name: GetRecentLoginAttemptsByIP :many
SELECT id, username, ip_address, user_agent, attempt_result, attempted_at, user_id, space_id, session_id FROM login_attempts
WHERE ip_address = $1
  AND attempted_at > $2
ORDER BY attempted_at DESC
`

type GetRecentLoginAttemptsByIPParams struct {
	IpAddress   pqtype.Inet `json:"ip_address"`
	AttemptedAt time.Time   `json:"attempted_at"`
}

func (q *Queries) GetRecentLoginAttemptsByIP(ctx context.Context, arg GetRecentLoginAttemptsByIPParams) ([]LoginAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getRecentLoginAttemptsByIP, arg.IpAddress, arg.AttemptedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptResult,
			&i.AttemptedAt,
			&i.UserID,
			&i.SpaceID,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLoginAttemptsByUsername = `-- name: GetRecentLoginAttemptsByUsername :many
SELECT id, username, ip_address, user_agent, attempt_result, attempted_at, user_id, space_id, session_id FROM login_attempts
WHERE username = $1
  AND attempted_at > $2
ORDER BY attempted_at DESC
`

type GetRecentLoginAttemptsByUsernameParams struct {
	Username    string    `json:"username"`
	AttemptedAt time.Time `json:"attempted_at"`
}

func (q *Queries) GetRecentLoginAttemptsByUsername(ctx context.Context, arg GetRecentLoginAttemptsByUsernameParams) ([]LoginAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getRecentLoginAttemptsByUsername, arg.Username, arg.AttemptedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptResult,
			&i.AttemptedAt,
			&i.UserID,
			&i.SpaceID,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :one
UPDATE users
SET failed_login_attempts = failed_login_attempts + 1,
    last_failed_login = NOW()
WHERE id = $1
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, incrementFailedLoginAttempts, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const resetFailedLoginAttempts = `-- name: ResetFailedLoginAttempts :one
UPDATE users
SET failed_login_attempts = 0,
    last_failed_login = NULL
WHERE id = $1
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

func (q *Queries) ResetFailedLoginAttempts(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, resetFailedLoginAttempts, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const unlockExpiredAccounts = `-- name: UnlockExpiredAccounts :exec
UPDATE users
SET is_locked = FALSE,
    locked_until = NULL,
    failed_login_attempts = 0
WHERE is_locked = TRUE
  AND locked_until IS NOT NULL
  AND locked_until < NOW()
`

func (q *Queries) UnlockExpiredAccounts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, unlockExpiredAccounts)
	return err
}

const updateUserLockStatus = `-- name: UpdateUserLockStatus :one

UPDATE users
SET is_locked = $2,
    locked_until = $3,
    failed_login_attempts = $4,
    last_failed_login = $5
WHERE id = $1
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateUserLockStatusParams struct {
	ID                  uuid.UUID    `json:"id"`
	IsLocked            bool         `json:"is_locked"`
	LockedUntil         sql.NullTime `json:"locked_until"`
	FailedLoginAttempts int32        `json:"failed_login_attempts"`
	LastFailedLogin     sql.NullTime `json:"last_failed_login"`
}

// Note: Account lockouts are now managed via users table fields (is_locked, locked_until, failed_login_attempts)
func (q *Queries) UpdateUserLockStatus(ctx context.Context, arg UpdateUserLockStatusParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserLockStatus,
		arg.ID,
		arg.IsLocked,
		arg.LockedUntil,
		arg.FailedLoginAttempts,
		arg.LastFailedLogin,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}
