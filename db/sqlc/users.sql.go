// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const advancedSearchUsers = `-- name: AdvancedSearchUsers :many
SELECT 
    u.id, u.space_id, u.username, u.email, u.password, u.full_name, u.avatar, u.bio, u.verified, u.roles, u.level, u.department, u.major, u.year, u.interests, u.followers_count, u.following_count, u.mentor_status, u.tutor_status, u.status, u.settings, u.phone_number, u.additional_phone_number, u.created_at, u.updated_at, u.is_locked, u.locked_until, u.failed_login_attempts, u.last_failed_login, u.suspended_until,
    ts_rank_cd(to_tsvector('english', 
        COALESCE(u.username, '') || ' ' || 
        COALESCE(u.full_name, '') || ' ' || 
        COALESCE(u.bio, '') || ' ' || 
        COALESCE(u.department, '') || ' ' || 
        COALESCE(u.major, '')
    ), plainto_tsquery('english', $1)) as relevance_score
FROM users u
WHERE u.space_id = $2 
  AND u.status = 'active'
  AND (
    to_tsvector('english', 
        COALESCE(u.username, '') || ' ' || 
        COALESCE(u.full_name, '') || ' ' || 
        COALESCE(u.bio, '') || ' ' || 
        COALESCE(u.department, '') || ' ' || 
        COALESCE(u.major, '')
    ) @@ plainto_tsquery('english', $1)
    OR u.username ILIKE '%' || $1 || '%'
    OR u.full_name ILIKE '%' || $1 || '%'
  )
ORDER BY relevance_score DESC, u.followers_count DESC
LIMIT $3 OFFSET $4
`

type AdvancedSearchUsersParams struct {
	PlaintoTsquery string    `json:"plainto_tsquery"`
	SpaceID        uuid.UUID `json:"space_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type AdvancedSearchUsersRow struct {
	ID                    uuid.UUID             `json:"id"`
	SpaceID               uuid.UUID             `json:"space_id"`
	Username              string                `json:"username"`
	Email                 string                `json:"email"`
	Password              string                `json:"password"`
	FullName              string                `json:"full_name"`
	Avatar                sql.NullString        `json:"avatar"`
	Bio                   sql.NullString        `json:"bio"`
	Verified              sql.NullBool          `json:"verified"`
	Roles                 []string              `json:"roles"`
	Level                 sql.NullString        `json:"level"`
	Department            sql.NullString        `json:"department"`
	Major                 sql.NullString        `json:"major"`
	Year                  sql.NullInt32         `json:"year"`
	Interests             []string              `json:"interests"`
	FollowersCount        sql.NullInt32         `json:"followers_count"`
	FollowingCount        sql.NullInt32         `json:"following_count"`
	MentorStatus          sql.NullString        `json:"mentor_status"`
	TutorStatus           sql.NullString        `json:"tutor_status"`
	Status                sql.NullString        `json:"status"`
	Settings              pqtype.NullRawMessage `json:"settings"`
	PhoneNumber           string                `json:"phone_number"`
	AdditionalPhoneNumber sql.NullString        `json:"additional_phone_number"`
	CreatedAt             sql.NullTime          `json:"created_at"`
	UpdatedAt             sql.NullTime          `json:"updated_at"`
	IsLocked              bool                  `json:"is_locked"`
	LockedUntil           sql.NullTime          `json:"locked_until"`
	FailedLoginAttempts   int32                 `json:"failed_login_attempts"`
	LastFailedLogin       sql.NullTime          `json:"last_failed_login"`
	SuspendedUntil        sql.NullTime          `json:"suspended_until"`
	RelevanceScore        float32               `json:"relevance_score"`
}

func (q *Queries) AdvancedSearchUsers(ctx context.Context, arg AdvancedSearchUsersParams) ([]AdvancedSearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, advancedSearchUsers,
		arg.PlaintoTsquery,
		arg.SpaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdvancedSearchUsersRow{}
	for rows.Next() {
		var i AdvancedSearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Verified,
			pq.Array(&i.Roles),
			&i.Level,
			&i.Department,
			&i.Major,
			&i.Year,
			pq.Array(&i.Interests),
			&i.FollowersCount,
			&i.FollowingCount,
			&i.MentorStatus,
			&i.TutorStatus,
			&i.Status,
			&i.Settings,
			&i.PhoneNumber,
			&i.AdditionalPhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsLocked,
			&i.LockedUntil,
			&i.FailedLoginAttempts,
			&i.LastFailedLogin,
			&i.SuspendedUntil,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkIfFollowing = `-- name: CheckIfFollowing :one
SELECT EXISTS(
    SELECT 1 FROM follows
    WHERE follower_id = $1 AND following_id = $2
) as is_following
`

type CheckIfFollowingParams struct {
	FollowerID  uuid.UUID `json:"follower_id"`
	FollowingID uuid.UUID `json:"following_id"`
}

func (q *Queries) CheckIfFollowing(ctx context.Context, arg CheckIfFollowingParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfFollowing, arg.FollowerID, arg.FollowingID)
	var is_following bool
	err := row.Scan(&is_following)
	return is_following, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    space_id, username, email, password, full_name, 
    roles, level, department, major, year, interests, settings, phone_number
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type CreateUserParams struct {
	SpaceID     uuid.UUID             `json:"space_id"`
	Username    string                `json:"username"`
	Email       string                `json:"email"`
	Password    string                `json:"password"`
	FullName    string                `json:"full_name"`
	Roles       []string              `json:"roles"`
	Level       sql.NullString        `json:"level"`
	Department  sql.NullString        `json:"department"`
	Major       sql.NullString        `json:"major"`
	Year        sql.NullInt32         `json:"year"`
	Interests   []string              `json:"interests"`
	Settings    pqtype.NullRawMessage `json:"settings"`
	PhoneNumber string                `json:"phone_number"`
}

// User Management Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.SpaceID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.FullName,
		pq.Array(arg.Roles),
		arg.Level,
		arg.Department,
		arg.Major,
		arg.Year,
		pq.Array(arg.Interests),
		arg.Settings,
		arg.PhoneNumber,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users SET status = 'inactive', updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deactivateUser, id)
	return err
}

const decrementFollowersCount = `-- name: DecrementFollowersCount :exec
UPDATE users
SET followers_count = GREATEST(0, followers_count - 1),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DecrementFollowersCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, decrementFollowersCount, id)
	return err
}

const decrementFollowingCount = `-- name: DecrementFollowingCount :exec
UPDATE users
SET following_count = GREATEST(0, following_count - 1),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DecrementFollowingCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, decrementFollowingCount, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const followUser = `-- name: FollowUser :one

INSERT INTO follows (follower_id, following_id, space_id)
VALUES ($1, $2, $3)
ON CONFLICT (follower_id, following_id) DO NOTHING
RETURNING id, follower_id, following_id, space_id, created_at
`

type FollowUserParams struct {
	FollowerID  uuid.UUID `json:"follower_id"`
	FollowingID uuid.UUID `json:"following_id"`
	SpaceID     uuid.UUID `json:"space_id"`
}

// Follow System Queries
func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (Follow, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID, arg.SpaceID)
	var i Follow
	err := row.Scan(
		&i.ID,
		&i.FollowerID,
		&i.FollowingID,
		&i.SpaceID,
		&i.CreatedAt,
	)
	return i, err
}

const getSuggestedUsers = `-- name: GetSuggestedUsers :many
SELECT
    u.id,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar,
    u.bio,
    u.verified,
    u.department,
    u.level,
    u.followers_count,
    u.following_count,
    COUNT(DISTINCT f.id) as mutual_followers
FROM users u
LEFT JOIN follows f ON u.id = f.following_id AND f.follower_id IN (
    SELECT following_id FROM follows fl WHERE fl.follower_id = $1
)
WHERE u.space_id = $2
  AND u.id != $1
  AND u.status = 'active'
  AND NOT EXISTS (SELECT 1 FROM follows WHERE follower_id = $1 AND following_id = u.id)
  AND (
    u.department = (SELECT department FROM users u2 WHERE u2.id = $1 AND department IS NOT NULL)
    OR u.level = (SELECT level FROM users u3 WHERE u3.id = $1 AND level IS NOT NULL)
    OR (u.interests && (SELECT interests FROM users u4 WHERE u4.id = $1) AND array_length(u.interests, 1) > 0)
    OR ((SELECT department FROM users u5 WHERE u5.id = $1) IS NULL AND (SELECT level FROM users u6 WHERE u6.id = $1) IS NULL)
  )
GROUP BY u.id
ORDER BY mutual_followers DESC, u.followers_count DESC
LIMIT $3 OFFSET $4
`

type GetSuggestedUsersParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	SpaceID    uuid.UUID `json:"space_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetSuggestedUsersRow struct {
	ID              uuid.UUID      `json:"id"`
	Username        interface{}    `json:"username"`
	FullName        interface{}    `json:"full_name"`
	Avatar          sql.NullString `json:"avatar"`
	Bio             sql.NullString `json:"bio"`
	Verified        sql.NullBool   `json:"verified"`
	Department      sql.NullString `json:"department"`
	Level           sql.NullString `json:"level"`
	FollowersCount  sql.NullInt32  `json:"followers_count"`
	FollowingCount  sql.NullInt32  `json:"following_count"`
	MutualFollowers int64          `json:"mutual_followers"`
}

func (q *Queries) GetSuggestedUsers(ctx context.Context, arg GetSuggestedUsersParams) ([]GetSuggestedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getSuggestedUsers,
		arg.FollowerID,
		arg.SpaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSuggestedUsersRow{}
	for rows.Next() {
		var i GetSuggestedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Verified,
			&i.Department,
			&i.Level,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.MutualFollowers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadNotificationCount = `-- name: GetUnreadNotificationCount :one
SELECT COUNT(*) FROM notifications
WHERE to_user_id = $1 AND is_read = false
`

func (q *Queries) GetUnreadNotificationCount(ctx context.Context, toUserID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadNotificationCount, toUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until FROM users 
WHERE email = $1  AND  status= 'active'
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    u.id, u.space_id, u.username, u.email, u.password, u.full_name, u.avatar, u.bio, u.verified, u.roles, u.level, u.department, u.major, u.year, u.interests, u.followers_count, u.following_count, u.mentor_status, u.tutor_status, u.status, u.settings, u.phone_number, u.additional_phone_number, u.created_at, u.updated_at, u.is_locked, u.locked_until, u.failed_login_attempts, u.last_failed_login, u.suspended_until,
    s.name as space_name,
    s.slug as space_slug
FROM users u
JOIN spaces s ON u.space_id = s.id
WHERE u.id = $1 AND u.status = 'active'
`

type GetUserByIDRow struct {
	ID                    uuid.UUID             `json:"id"`
	SpaceID               uuid.UUID             `json:"space_id"`
	Username              string                `json:"username"`
	Email                 string                `json:"email"`
	Password              string                `json:"password"`
	FullName              string                `json:"full_name"`
	Avatar                sql.NullString        `json:"avatar"`
	Bio                   sql.NullString        `json:"bio"`
	Verified              sql.NullBool          `json:"verified"`
	Roles                 []string              `json:"roles"`
	Level                 sql.NullString        `json:"level"`
	Department            sql.NullString        `json:"department"`
	Major                 sql.NullString        `json:"major"`
	Year                  sql.NullInt32         `json:"year"`
	Interests             []string              `json:"interests"`
	FollowersCount        sql.NullInt32         `json:"followers_count"`
	FollowingCount        sql.NullInt32         `json:"following_count"`
	MentorStatus          sql.NullString        `json:"mentor_status"`
	TutorStatus           sql.NullString        `json:"tutor_status"`
	Status                sql.NullString        `json:"status"`
	Settings              pqtype.NullRawMessage `json:"settings"`
	PhoneNumber           string                `json:"phone_number"`
	AdditionalPhoneNumber sql.NullString        `json:"additional_phone_number"`
	CreatedAt             sql.NullTime          `json:"created_at"`
	UpdatedAt             sql.NullTime          `json:"updated_at"`
	IsLocked              bool                  `json:"is_locked"`
	LockedUntil           sql.NullTime          `json:"locked_until"`
	FailedLoginAttempts   int32                 `json:"failed_login_attempts"`
	LastFailedLogin       sql.NullTime          `json:"last_failed_login"`
	SuspendedUntil        sql.NullTime          `json:"suspended_until"`
	SpaceName             string                `json:"space_name"`
	SpaceSlug             string                `json:"space_slug"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
		&i.SpaceName,
		&i.SpaceSlug,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until FROM users 
WHERE username = $1  AND status = 'active'
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const getUserEngagementAnalytics = `-- name: GetUserEngagementAnalytics :one
SELECT
    COUNT(DISTINCT p.id) as posts_created,
    COUNT(DISTINCT l.id) as likes_given,
    (SELECT COUNT(*) FROM likes l2
     JOIN posts p2 ON l2.post_id = p2.id
     WHERE p2.author_id = $1) as likes_received,
    COUNT(DISTINCT c.id) as comments_made,
    COUNT(DISTINCT cm.community_id) as communities_joined,
    COUNT(DISTINCT gm.group_id) as groups_joined,
    COUNT(DISTINCT ea.event_id) as events_attended,
    COUNT(DISTINCT ts.id) + COUNT(DISTINCT ms.id) as sessions_completed
FROM users u
LEFT JOIN posts p ON u.id = p.author_id AND p.status = 'active'
LEFT JOIN likes l ON u.id = l.user_id
LEFT JOIN comments c ON u.id = c.author_id AND c.status = 'active'
LEFT JOIN community_members cm ON u.id = cm.user_id
LEFT JOIN group_members gm ON u.id = gm.user_id
LEFT JOIN event_attendees ea ON u.id = ea.user_id AND ea.status = 'attended'
LEFT JOIN tutoring_sessions ts ON (u.id = ts.tutor_id OR u.id = ts.student_id) AND ts.status = 'completed'
LEFT JOIN mentoring_sessions ms ON (u.id = ms.mentor_id OR u.id = ms.mentee_id) AND ms.status = 'completed'
WHERE u.id = $1
GROUP BY u.id
`

type GetUserEngagementAnalyticsRow struct {
	PostsCreated      int64 `json:"posts_created"`
	LikesGiven        int64 `json:"likes_given"`
	LikesReceived     int64 `json:"likes_received"`
	CommentsMade      int64 `json:"comments_made"`
	CommunitiesJoined int64 `json:"communities_joined"`
	GroupsJoined      int64 `json:"groups_joined"`
	EventsAttended    int64 `json:"events_attended"`
	SessionsCompleted int32 `json:"sessions_completed"`
}

func (q *Queries) GetUserEngagementAnalytics(ctx context.Context, authorID uuid.UUID) (GetUserEngagementAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserEngagementAnalytics, authorID)
	var i GetUserEngagementAnalyticsRow
	err := row.Scan(
		&i.PostsCreated,
		&i.LikesGiven,
		&i.LikesReceived,
		&i.CommentsMade,
		&i.CommunitiesJoined,
		&i.GroupsJoined,
		&i.EventsAttended,
		&i.SessionsCompleted,
	)
	return i, err
}

const getUserFollowers = `-- name: GetUserFollowers :many
SELECT
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    u.bio,
    u.verified,
    u.followers_count,
    u.following_count,
    f.created_at as followed_at
FROM follows f
JOIN users u ON f.follower_id = u.id
WHERE f.following_id = $1
  AND u.status = 'active'
ORDER BY f.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserFollowersParams struct {
	FollowingID uuid.UUID `json:"following_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetUserFollowersRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	FullName       string         `json:"full_name"`
	Avatar         sql.NullString `json:"avatar"`
	Bio            sql.NullString `json:"bio"`
	Verified       sql.NullBool   `json:"verified"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	FollowedAt     sql.NullTime   `json:"followed_at"`
}

func (q *Queries) GetUserFollowers(ctx context.Context, arg GetUserFollowersParams) ([]GetUserFollowersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserFollowers, arg.FollowingID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFollowersRow{}
	for rows.Next() {
		var i GetUserFollowersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Verified,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFollowing = `-- name: GetUserFollowing :many
SELECT
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    u.bio,
    u.verified,
    u.followers_count,
    u.following_count,
    f.created_at as followed_at
FROM follows f
JOIN users u ON f.following_id = u.id
WHERE f.follower_id = $1
  AND u.status = 'active'
ORDER BY f.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserFollowingParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetUserFollowingRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	FullName       string         `json:"full_name"`
	Avatar         sql.NullString `json:"avatar"`
	Bio            sql.NullString `json:"bio"`
	Verified       sql.NullBool   `json:"verified"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	FollowedAt     sql.NullTime   `json:"followed_at"`
}

func (q *Queries) GetUserFollowing(ctx context.Context, arg GetUserFollowingParams) ([]GetUserFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserFollowing, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFollowingRow{}
	for rows.Next() {
		var i GetUserFollowingRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Verified,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionActivity = `-- name: GetUserSessionActivity :many
SELECT id, user_id, space_id, username, refresh_token, user_agent, ip_address, is_blocked, last_activity, expires_at, created_at FROM user_sessions
WHERE user_id = $1
ORDER BY last_activity DESC
LIMIT $2 OFFSET $3
`

type GetUserSessionActivityParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetUserSessionActivity(ctx context.Context, arg GetUserSessionActivityParams) ([]UserSession, error) {
	rows, err := q.db.QueryContext(ctx, getUserSessionActivity, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SpaceID,
			&i.Username,
			&i.RefreshToken,
			&i.UserAgent,
			&i.IpAddress,
			&i.IsBlocked,
			&i.LastActivity,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSettings = `-- name: GetUserSettings :one

SELECT settings FROM users
WHERE id = $1
`

// Note: User preferences are now stored in users.settings JSONB field
// Note: User activities are now tracked via user_sessions table
func (q *Queries) GetUserSettings(ctx context.Context, id uuid.UUID) (pqtype.NullRawMessage, error) {
	row := q.db.QueryRowContext(ctx, getUserSettings, id)
	var settings pqtype.NullRawMessage
	err := row.Scan(&settings)
	return settings, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT 
    COUNT(*) as total_posts,
    COUNT(DISTINCT flwrs.follower_id) as total_followers,
    COUNT(DISTINCT flwng.following_id) as total_following,
    COUNT(DISTINCT gm.group_id) as total_groups,
    COUNT(DISTINCT cm.community_id) as total_communities,
    COUNT(DISTINCT ts.id) as total_tutoring_sessions,
    COUNT(DISTINCT ms.id) as total_mentoring_sessions
FROM users u
LEFT JOIN posts p ON u.id = p.author_id AND p.status = 'active'
LEFT JOIN follows flwrs ON u.id = flwrs.following_id
LEFT JOIN follows flwng ON u.id = flwng.follower_id
LEFT JOIN group_members gm ON u.id = gm.user_id
LEFT JOIN community_members cm ON u.id = cm.user_id
LEFT JOIN tutoring_sessions ts ON u.id = ts.tutor_id OR u.id = ts.student_id
LEFT JOIN mentoring_sessions ms ON u.id = ms.mentor_id OR u.id = ms.mentee_id
WHERE u.id = $1
GROUP BY u.id
`

type GetUserStatsRow struct {
	TotalPosts             int64 `json:"total_posts"`
	TotalFollowers         int64 `json:"total_followers"`
	TotalFollowing         int64 `json:"total_following"`
	TotalGroups            int64 `json:"total_groups"`
	TotalCommunities       int64 `json:"total_communities"`
	TotalTutoringSessions  int64 `json:"total_tutoring_sessions"`
	TotalMentoringSessions int64 `json:"total_mentoring_sessions"`
}

func (q *Queries) GetUserStats(ctx context.Context, id uuid.UUID) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, id)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalPosts,
		&i.TotalFollowers,
		&i.TotalFollowing,
		&i.TotalGroups,
		&i.TotalCommunities,
		&i.TotalTutoringSessions,
		&i.TotalMentoringSessions,
	)
	return i, err
}

const getUsersByRole = `-- name: GetUsersByRole :many
SELECT 
    id,
    username,
    full_name,
    avatar,
    level,
    department,
    verified,
    mentor_status,
    tutor_status
FROM users 
WHERE space_id = $1 
  AND status = 'active'
  AND $2 = ANY(roles)
ORDER BY full_name
`

type GetUsersByRoleParams struct {
	SpaceID uuid.UUID `json:"space_id"`
	Roles   []string  `json:"roles"`
}

type GetUsersByRoleRow struct {
	ID           uuid.UUID      `json:"id"`
	Username     string         `json:"username"`
	FullName     string         `json:"full_name"`
	Avatar       sql.NullString `json:"avatar"`
	Level        sql.NullString `json:"level"`
	Department   sql.NullString `json:"department"`
	Verified     sql.NullBool   `json:"verified"`
	MentorStatus sql.NullString `json:"mentor_status"`
	TutorStatus  sql.NullString `json:"tutor_status"`
}

func (q *Queries) GetUsersByRole(ctx context.Context, arg GetUsersByRoleParams) ([]GetUsersByRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByRole, arg.SpaceID, pq.Array(arg.Roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByRoleRow{}
	for rows.Next() {
		var i GetUsersByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Level,
			&i.Department,
			&i.Verified,
			&i.MentorStatus,
			&i.TutorStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithPendingApplications = `-- name: GetUsersWithPendingApplications :many
SELECT 
    u.id, u.space_id, u.username, u.email, u.password, u.full_name, u.avatar, u.bio, u.verified, u.roles, u.level, u.department, u.major, u.year, u.interests, u.followers_count, u.following_count, u.mentor_status, u.tutor_status, u.status, u.settings, u.phone_number, u.additional_phone_number, u.created_at, u.updated_at, u.is_locked, u.locked_until, u.failed_login_attempts, u.last_failed_login, u.suspended_until,
    ta.id as tutor_application_id,
    ma.id as mentor_application_id
FROM users u
LEFT JOIN tutor_applications ta ON u.id = ta.applicant_id AND ta.status = 'pending'
LEFT JOIN mentor_applications ma ON u.id = ma.applicant_id AND ma.status = 'pending'
WHERE u.space_id = $1 
  AND (ta.id IS NOT NULL OR ma.id IS NOT NULL)
  AND u.status = 'active'
`

type GetUsersWithPendingApplicationsRow struct {
	ID                    uuid.UUID             `json:"id"`
	SpaceID               uuid.UUID             `json:"space_id"`
	Username              string                `json:"username"`
	Email                 string                `json:"email"`
	Password              string                `json:"password"`
	FullName              string                `json:"full_name"`
	Avatar                sql.NullString        `json:"avatar"`
	Bio                   sql.NullString        `json:"bio"`
	Verified              sql.NullBool          `json:"verified"`
	Roles                 []string              `json:"roles"`
	Level                 sql.NullString        `json:"level"`
	Department            sql.NullString        `json:"department"`
	Major                 sql.NullString        `json:"major"`
	Year                  sql.NullInt32         `json:"year"`
	Interests             []string              `json:"interests"`
	FollowersCount        sql.NullInt32         `json:"followers_count"`
	FollowingCount        sql.NullInt32         `json:"following_count"`
	MentorStatus          sql.NullString        `json:"mentor_status"`
	TutorStatus           sql.NullString        `json:"tutor_status"`
	Status                sql.NullString        `json:"status"`
	Settings              pqtype.NullRawMessage `json:"settings"`
	PhoneNumber           string                `json:"phone_number"`
	AdditionalPhoneNumber sql.NullString        `json:"additional_phone_number"`
	CreatedAt             sql.NullTime          `json:"created_at"`
	UpdatedAt             sql.NullTime          `json:"updated_at"`
	IsLocked              bool                  `json:"is_locked"`
	LockedUntil           sql.NullTime          `json:"locked_until"`
	FailedLoginAttempts   int32                 `json:"failed_login_attempts"`
	LastFailedLogin       sql.NullTime          `json:"last_failed_login"`
	SuspendedUntil        sql.NullTime          `json:"suspended_until"`
	TutorApplicationID    uuid.NullUUID         `json:"tutor_application_id"`
	MentorApplicationID   uuid.NullUUID         `json:"mentor_application_id"`
}

func (q *Queries) GetUsersWithPendingApplications(ctx context.Context, spaceID uuid.UUID) ([]GetUsersWithPendingApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithPendingApplications, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersWithPendingApplicationsRow{}
	for rows.Next() {
		var i GetUsersWithPendingApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Verified,
			pq.Array(&i.Roles),
			&i.Level,
			&i.Department,
			&i.Major,
			&i.Year,
			pq.Array(&i.Interests),
			&i.FollowersCount,
			&i.FollowingCount,
			&i.MentorStatus,
			&i.TutorStatus,
			&i.Status,
			&i.Settings,
			&i.PhoneNumber,
			&i.AdditionalPhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsLocked,
			&i.LockedUntil,
			&i.FailedLoginAttempts,
			&i.LastFailedLogin,
			&i.SuspendedUntil,
			&i.TutorApplicationID,
			&i.MentorApplicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementFollowersCount = `-- name: IncrementFollowersCount :exec
UPDATE users
SET followers_count = followers_count + 1,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementFollowersCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementFollowersCount, id)
	return err
}

const incrementFollowingCount = `-- name: IncrementFollowingCount :exec
UPDATE users
SET following_count = following_count + 1,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementFollowingCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementFollowingCount, id)
	return err
}

const listUsers = `-- name: ListUsers :many

SELECT
    id,
    username,
    full_name,
    email,
    avatar,
    status,
    created_at,
    roles, 
    department
FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUsersRow struct {
	ID         uuid.UUID      `json:"id"`
	Username   string         `json:"username"`
	FullName   string         `json:"full_name"`
	Email      string         `json:"email"`
	Avatar     sql.NullString `json:"avatar"`
	Status     sql.NullString `json:"status"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	Roles      []string       `json:"roles"`
	Department sql.NullString `json:"department"`
}

// Admin User Management Queries
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Avatar,
			&i.Status,
			&i.CreatedAt,
			pq.Array(&i.Roles),
			&i.Department,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationsAsRead = `-- name: MarkNotificationsAsRead :exec

UPDATE notifications 
SET is_read = true, read_at = NOW() 
WHERE to_user_id = $1 AND is_read = false
`

// -- name: GetUserNotifications :many
// SELECT *
// FROM notifications
// WHERE to_user_id = $1
// ORDER BY created_at DESC
// LIMIT $2 OFFSET $3;
func (q *Queries) MarkNotificationsAsRead(ctx context.Context, toUserID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markNotificationsAsRead, toUserID)
	return err
}

const searchUsers = `-- name: SearchUsers :many
SELECT 
    id,
    username,
    full_name,
    avatar,
    bio,
    level,
    department,
    major,
    verified,
    followers_count,
    following_count
FROM users 
WHERE space_id = $1 
  AND status = 'active'
  AND (username ILIKE $2 OR full_name ILIKE $2 OR department ILIKE $2 OR bio ILIKE $2)
ORDER BY 
    CASE 
        WHEN username = $2 THEN 1
        WHEN full_name = $2 THEN 2
        ELSE 3
    END,
    followers_count DESC
LIMIT 50
`

type SearchUsersParams struct {
	SpaceID  uuid.UUID `json:"space_id"`
	Username string    `json:"username"`
}

type SearchUsersRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	FullName       string         `json:"full_name"`
	Avatar         sql.NullString `json:"avatar"`
	Bio            sql.NullString `json:"bio"`
	Level          sql.NullString `json:"level"`
	Department     sql.NullString `json:"department"`
	Major          sql.NullString `json:"major"`
	Verified       sql.NullBool   `json:"verified"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	FollowingCount sql.NullInt32  `json:"following_count"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, arg.SpaceID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersRow{}
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Bio,
			&i.Level,
			&i.Department,
			&i.Major,
			&i.Verified,
			&i.FollowersCount,
			&i.FollowingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM follows
WHERE follower_id = $1 AND following_id = $2
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID `json:"follower_id"`
	FollowingID uuid.UUID `json:"following_id"`
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error {
	_, err := q.db.ExecContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	return err
}

const updateMentorStatus = `-- name: UpdateMentorStatus :one
UPDATE users 
SET mentor_status = $1, updated_at = NOW() 
WHERE id = $2 
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateMentorStatusParams struct {
	MentorStatus sql.NullString `json:"mentor_status"`
	ID           uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateMentorStatus(ctx context.Context, arg UpdateMentorStatusParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateMentorStatus, arg.MentorStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const updateTutorStatus = `-- name: UpdateTutorStatus :one
UPDATE users 
SET tutor_status = $1, updated_at = NOW() 
WHERE id = $2 
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateTutorStatusParams struct {
	TutorStatus sql.NullString `json:"tutor_status"`
	ID          uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateTutorStatus(ctx context.Context, arg UpdateTutorStatusParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateTutorStatus, arg.TutorStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET 
    full_name = $1,
    bio = $2,
    avatar = $3,
    level = $4,
    department = $5,
    major = $6,
    year = $7,
    interests = $8,
    settings = $9,
    updated_at = NOW()
WHERE id = $10 AND status = 'active'
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateUserParams struct {
	FullName   string                `json:"full_name"`
	Bio        sql.NullString        `json:"bio"`
	Avatar     sql.NullString        `json:"avatar"`
	Level      sql.NullString        `json:"level"`
	Department sql.NullString        `json:"department"`
	Major      sql.NullString        `json:"major"`
	Year       sql.NullInt32         `json:"year"`
	Interests  []string              `json:"interests"`
	Settings   pqtype.NullRawMessage `json:"settings"`
	ID         uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.FullName,
		arg.Bio,
		arg.Avatar,
		arg.Level,
		arg.Department,
		arg.Major,
		arg.Year,
		pq.Array(arg.Interests),
		arg.Settings,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const updateUserLastActive = `-- name: UpdateUserLastActive :exec
UPDATE users SET last_active = NOW() WHERE id = $1
`

func (q *Queries) UpdateUserLastActive(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastActive, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users 
SET password = $1, updated_at = NOW() 
WHERE id = $2
`

type UpdateUserPasswordParams struct {
	Password string    `json:"password"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.Password, arg.ID)
	return err
}

const updateUserSettings = `-- name: UpdateUserSettings :one
UPDATE users
SET settings = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateUserSettingsParams struct {
	ID       uuid.UUID             `json:"id"`
	Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) UpdateUserSettings(ctx context.Context, arg UpdateUserSettingsParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserSettings, arg.ID, arg.Settings)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}
