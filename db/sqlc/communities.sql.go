// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: communities.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const addCommunityModerator = `-- name: AddCommunityModerator :one
INSERT INTO community_members (community_id, user_id, permissions, role)
VALUES ($1, $2, $3, 'moderator')
RETURNING id, community_id, user_id, role, permissions, joined_at
`

type AddCommunityModeratorParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
	Permissions []string  `json:"permissions"`
}

func (q *Queries) AddCommunityModerator(ctx context.Context, arg AddCommunityModeratorParams) (CommunityMember, error) {
	row := q.db.QueryRowContext(ctx, addCommunityModerator, arg.CommunityID, arg.UserID, pq.Array(arg.Permissions))
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		pq.Array(&i.Permissions),
		&i.JoinedAt,
	)
	return i, err
}

const createCommunity = `-- name: CreateCommunity :one

INSERT INTO communities (
    space_id, name, description, category, cover_image, is_public, created_by, settings
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, space_id, name, description, category, cover_image, member_count, status, post_count, is_public, created_by, settings, created_at, updated_at
`

type CreateCommunityParams struct {
	SpaceID     uuid.UUID             `json:"space_id"`
	Name        string                `json:"name"`
	Description sql.NullString        `json:"description"`
	Category    string                `json:"category"`
	CoverImage  sql.NullString        `json:"cover_image"`
	IsPublic    sql.NullBool          `json:"is_public"`
	CreatedBy   uuid.NullUUID         `json:"created_by"`
	Settings    pqtype.NullRawMessage `json:"settings"`
}

// Communities Management Queries
func (q *Queries) CreateCommunity(ctx context.Context, arg CreateCommunityParams) (Community, error) {
	row := q.db.QueryRowContext(ctx, createCommunity,
		arg.SpaceID,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.CoverImage,
		arg.IsPublic,
		arg.CreatedBy,
		arg.Settings,
	)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.CoverImage,
		&i.MemberCount,
		&i.Status,
		&i.PostCount,
		&i.IsPublic,
		&i.CreatedBy,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCommunity = `-- name: DeleteCommunity :exec
DELETE FROM communities WHERE id = $1
`

func (q *Queries) DeleteCommunity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCommunity, id)
	return err
}

const getCommunityAdmins = `-- name: GetCommunityAdmins :many
SELECT
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    ca.permissions
FROM community_members ca
JOIN users u ON ca.user_id = u.id
WHERE ca.community_id = $1 AND ca.role = 'admin' AND u.status = 'active'
`

type GetCommunityAdminsRow struct {
	ID          uuid.UUID      `json:"id"`
	Username    string         `json:"username"`
	FullName    string         `json:"full_name"`
	Avatar      sql.NullString `json:"avatar"`
	Permissions []string       `json:"permissions"`
}

func (q *Queries) GetCommunityAdmins(ctx context.Context, communityID uuid.UUID) ([]GetCommunityAdminsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityAdmins, communityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommunityAdminsRow{}
	for rows.Next() {
		var i GetCommunityAdminsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			pq.Array(&i.Permissions),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityByID = `-- name: GetCommunityByID :one
SELECT 
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    u.username as created_by_username,
    u.full_name as created_by_full_name,
    EXISTS(SELECT 1 FROM community_members cm2 WHERE cm2.community_id = c.id AND cm2.user_id = $1) as is_member,
    cm.role as user_role,
    (SELECT COUNT(*) FROM community_members cm3 WHERE cm3.community_id = c.id) as actual_member_count,
    (SELECT COUNT(*) FROM posts WHERE community_id = c.id AND status = 'active') as actual_post_count
FROM communities c
JOIN users u ON c.created_by = u.id
LEFT JOIN community_members cm ON c.id = cm.community_id AND cm.user_id = $1
WHERE c.id = $2
`

type GetCommunityByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

type GetCommunityByIDRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	CoverImage        sql.NullString        `json:"cover_image"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	Status            sql.NullString        `json:"status"`
	PostCount         sql.NullInt32         `json:"post_count"`
	IsPublic          sql.NullBool          `json:"is_public"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CreatedByUsername string                `json:"created_by_username"`
	CreatedByFullName string                `json:"created_by_full_name"`
	IsMember          bool                  `json:"is_member"`
	UserRole          sql.NullString        `json:"user_role"`
	ActualMemberCount int64                 `json:"actual_member_count"`
	ActualPostCount   int64                 `json:"actual_post_count"`
}

func (q *Queries) GetCommunityByID(ctx context.Context, arg GetCommunityByIDParams) (GetCommunityByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCommunityByID, arg.UserID, arg.ID)
	var i GetCommunityByIDRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.CoverImage,
		&i.MemberCount,
		&i.Status,
		&i.PostCount,
		&i.IsPublic,
		&i.CreatedBy,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedByUsername,
		&i.CreatedByFullName,
		&i.IsMember,
		&i.UserRole,
		&i.ActualMemberCount,
		&i.ActualPostCount,
	)
	return i, err
}

const getCommunityBySlug = `-- name: GetCommunityBySlug :one
SELECT 
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    u.username as created_by_username,
    u.full_name as created_by_full_name,
    EXISTS(SELECT 1 FROM community_members cm2 WHERE cm2.community_id = c.id AND cm2.user_id = $1) as is_member,
    cm.role as user_role
FROM communities c
JOIN users u ON c.created_by = u.id
LEFT JOIN community_members cm ON c.id = cm.community_id AND cm.user_id = $1
WHERE c.space_id = $2 AND LOWER(c.name) = LOWER($3)
`

type GetCommunityBySlugParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
	Lower   string    `json:"lower"`
}

type GetCommunityBySlugRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	CoverImage        sql.NullString        `json:"cover_image"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	Status            sql.NullString        `json:"status"`
	PostCount         sql.NullInt32         `json:"post_count"`
	IsPublic          sql.NullBool          `json:"is_public"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CreatedByUsername string                `json:"created_by_username"`
	CreatedByFullName string                `json:"created_by_full_name"`
	IsMember          bool                  `json:"is_member"`
	UserRole          sql.NullString        `json:"user_role"`
}

func (q *Queries) GetCommunityBySlug(ctx context.Context, arg GetCommunityBySlugParams) (GetCommunityBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getCommunityBySlug, arg.UserID, arg.SpaceID, arg.Lower)
	var i GetCommunityBySlugRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.CoverImage,
		&i.MemberCount,
		&i.Status,
		&i.PostCount,
		&i.IsPublic,
		&i.CreatedBy,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedByUsername,
		&i.CreatedByFullName,
		&i.IsMember,
		&i.UserRole,
	)
	return i, err
}

const getCommunityCategories = `-- name: GetCommunityCategories :many
SELECT DISTINCT category 
FROM communities 
WHERE space_id = $1 
ORDER BY category
`

func (q *Queries) GetCommunityCategories(ctx context.Context, spaceID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityCategories, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityMembers = `-- name: GetCommunityMembers :many
SELECT 
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    u.level,
    u.department,
    u.verified,
    cm.role,
    cm.joined_at
FROM community_members cm
JOIN users u ON cm.user_id = u.id
WHERE cm.community_id = $1 AND u.status = 'active'
ORDER BY
    cm.joined_at
`

type GetCommunityMembersRow struct {
	ID         uuid.UUID      `json:"id"`
	Username   string         `json:"username"`
	FullName   string         `json:"full_name"`
	Avatar     sql.NullString `json:"avatar"`
	Level      sql.NullString `json:"level"`
	Department sql.NullString `json:"department"`
	Verified   sql.NullBool   `json:"verified"`
	Role       string         `json:"role"`
	JoinedAt   sql.NullTime   `json:"joined_at"`
}

func (q *Queries) GetCommunityMembers(ctx context.Context, communityID uuid.UUID) ([]GetCommunityMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityMembers, communityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommunityMembersRow{}
	for rows.Next() {
		var i GetCommunityMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Level,
			&i.Department,
			&i.Verified,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityModerators = `-- name: GetCommunityModerators :many
SELECT 
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    cm.permissions
FROM community_members cm
JOIN users u ON cm.user_id = u.id
WHERE cm.community_id = $1 AND u.status = 'active' AND role='moderator'
`

type GetCommunityModeratorsRow struct {
	ID          uuid.UUID      `json:"id"`
	Username    string         `json:"username"`
	FullName    string         `json:"full_name"`
	Avatar      sql.NullString `json:"avatar"`
	Permissions []string       `json:"permissions"`
}

func (q *Queries) GetCommunityModerators(ctx context.Context, communityID uuid.UUID) ([]GetCommunityModeratorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityModerators, communityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommunityModeratorsRow{}
	for rows.Next() {
		var i GetCommunityModeratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			pq.Array(&i.Permissions),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCommunities = `-- name: GetUserCommunities :many
SELECT
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    cm.role as user_role,
    cm.joined_at
FROM communities c
JOIN community_members cm ON c.id = cm.community_id
WHERE cm.user_id = $1 AND c.space_id = $2
ORDER BY cm.joined_at DESC
`

type GetUserCommunitiesParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
}

type GetUserCommunitiesRow struct {
	ID          uuid.UUID             `json:"id"`
	SpaceID     uuid.UUID             `json:"space_id"`
	Name        string                `json:"name"`
	Description sql.NullString        `json:"description"`
	Category    string                `json:"category"`
	CoverImage  sql.NullString        `json:"cover_image"`
	MemberCount sql.NullInt32         `json:"member_count"`
	Status      sql.NullString        `json:"status"`
	PostCount   sql.NullInt32         `json:"post_count"`
	IsPublic    sql.NullBool          `json:"is_public"`
	CreatedBy   uuid.NullUUID         `json:"created_by"`
	Settings    pqtype.NullRawMessage `json:"settings"`
	CreatedAt   sql.NullTime          `json:"created_at"`
	UpdatedAt   sql.NullTime          `json:"updated_at"`
	UserRole    string                `json:"user_role"`
	JoinedAt    sql.NullTime          `json:"joined_at"`
}

func (q *Queries) GetUserCommunities(ctx context.Context, arg GetUserCommunitiesParams) ([]GetUserCommunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCommunities, arg.UserID, arg.SpaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCommunitiesRow{}
	for rows.Next() {
		var i GetUserCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.CoverImage,
			&i.MemberCount,
			&i.Status,
			&i.PostCount,
			&i.IsPublic,
			&i.CreatedBy,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRole,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isCommunityAdmin = `-- name: IsCommunityAdmin :one
SELECT EXISTS(
    SELECT 1 FROM community_members cm 
    WHERE cm.community_id = $1 AND cm.user_id = $2 AND cm.role = 'admin'
) as is_admin
`

type IsCommunityAdminParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) IsCommunityAdmin(ctx context.Context, arg IsCommunityAdminParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isCommunityAdmin, arg.CommunityID, arg.UserID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isCommunityModerator = `-- name: IsCommunityModerator :one
SELECT EXISTS(
    SELECT 1 FROM community_members cm 
    WHERE cm.community_id = $1 AND cm.user_id = $2 AND role = 'moderator'
) as is_moderator
`

type IsCommunityModeratorParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) IsCommunityModerator(ctx context.Context, arg IsCommunityModeratorParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isCommunityModerator, arg.CommunityID, arg.UserID)
	var is_moderator bool
	err := row.Scan(&is_moderator)
	return is_moderator, err
}

const joinCommunity = `-- name: JoinCommunity :one
INSERT INTO community_members (community_id, user_id, role)
VALUES ($1, $2, 'member')
ON CONFLICT (community_id, user_id) 
DO UPDATE SET role = 'member', joined_at = NOW()
RETURNING id, community_id, user_id, role, permissions, joined_at
`

type JoinCommunityParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) JoinCommunity(ctx context.Context, arg JoinCommunityParams) (CommunityMember, error) {
	row := q.db.QueryRowContext(ctx, joinCommunity, arg.CommunityID, arg.UserID)
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		pq.Array(&i.Permissions),
		&i.JoinedAt,
	)
	return i, err
}

const leaveCommunity = `-- name: LeaveCommunity :exec
DELETE FROM community_members 
WHERE community_id = $1 AND user_id = $2
`

type LeaveCommunityParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) LeaveCommunity(ctx context.Context, arg LeaveCommunityParams) error {
	_, err := q.db.ExecContext(ctx, leaveCommunity, arg.CommunityID, arg.UserID)
	return err
}

const listAllCommunitiesAdmin = `-- name: ListAllCommunitiesAdmin :many

SELECT
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    u.username as created_by_username,
    u.full_name as created_by_full_name,
    (SELECT COUNT(*) FROM community_members cm WHERE cm.community_id = c.id) as actual_member_count,
    (SELECT COUNT(*) FROM posts WHERE community_id = c.id AND status = 'active') as actual_post_count
FROM communities c
LEFT JOIN users u ON c.created_by = u.id
WHERE c.space_id = $1
  OR (c.category = $2 OR $2 = '')
  OR (c.status = $3 OR $3 = '')
ORDER BY c.created_at DESC
LIMIT $4 OFFSET $5
`

type ListAllCommunitiesAdminParams struct {
	SpaceID  uuid.UUID      `json:"space_id"`
	Category string         `json:"category"`
	Status   sql.NullString `json:"status"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
}

type ListAllCommunitiesAdminRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	CoverImage        sql.NullString        `json:"cover_image"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	Status            sql.NullString        `json:"status"`
	PostCount         sql.NullInt32         `json:"post_count"`
	IsPublic          sql.NullBool          `json:"is_public"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	CreatedByUsername sql.NullString        `json:"created_by_username"`
	CreatedByFullName sql.NullString        `json:"created_by_full_name"`
	ActualMemberCount int64                 `json:"actual_member_count"`
	ActualPostCount   int64                 `json:"actual_post_count"`
}

// Admin-specific Community Queries
func (q *Queries) ListAllCommunitiesAdmin(ctx context.Context, arg ListAllCommunitiesAdminParams) ([]ListAllCommunitiesAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCommunitiesAdmin,
		arg.SpaceID,
		arg.Category,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllCommunitiesAdminRow{}
	for rows.Next() {
		var i ListAllCommunitiesAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.CoverImage,
			&i.MemberCount,
			&i.Status,
			&i.PostCount,
			&i.IsPublic,
			&i.CreatedBy,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUsername,
			&i.CreatedByFullName,
			&i.ActualMemberCount,
			&i.ActualPostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommunities = `-- name: ListCommunities :many
SELECT 
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    cm.role as user_role,
    EXISTS(SELECT 1 FROM community_members cm2 WHERE cm2.community_id = c.id AND cm2.user_id = $1) as is_member,
    (SELECT COUNT(*) FROM community_members cm3 WHERE cm3.community_id = c.id) as actual_member_count
FROM communities c
LEFT JOIN community_members cm ON c.id = cm.community_id AND cm.user_id = $1
WHERE c.space_id = $2
ORDER BY 
    CASE WHEN $3 = 'members' THEN c.member_count END DESC,
    CASE WHEN $3 = 'posts' THEN c.post_count END DESC,
    CASE WHEN $3 = 'recent' THEN c.created_at END DESC,
    c.name ASC
LIMIT $4 OFFSET $5
`

type ListCommunitiesParams struct {
	UserID  uuid.UUID   `json:"user_id"`
	SpaceID uuid.UUID   `json:"space_id"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListCommunitiesRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	CoverImage        sql.NullString        `json:"cover_image"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	Status            sql.NullString        `json:"status"`
	PostCount         sql.NullInt32         `json:"post_count"`
	IsPublic          sql.NullBool          `json:"is_public"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	UserRole          sql.NullString        `json:"user_role"`
	IsMember          bool                  `json:"is_member"`
	ActualMemberCount int64                 `json:"actual_member_count"`
}

func (q *Queries) ListCommunities(ctx context.Context, arg ListCommunitiesParams) ([]ListCommunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCommunities,
		arg.UserID,
		arg.SpaceID,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommunitiesRow{}
	for rows.Next() {
		var i ListCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.CoverImage,
			&i.MemberCount,
			&i.Status,
			&i.PostCount,
			&i.IsPublic,
			&i.CreatedBy,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRole,
			&i.IsMember,
			&i.ActualMemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCommunityModerator = `-- name: RemoveCommunityModerator :exec
DELETE FROM community_members WHERE community_id = $1 AND user_id = $2 AND role = 'moderator'
`

type RemoveCommunityModeratorParams struct {
	CommunityID uuid.UUID `json:"community_id"`
	UserID      uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveCommunityModerator(ctx context.Context, arg RemoveCommunityModeratorParams) error {
	_, err := q.db.ExecContext(ctx, removeCommunityModerator, arg.CommunityID, arg.UserID)
	return err
}

const searchCommunities = `-- name: SearchCommunities :many
SELECT 
    c.id, c.space_id, c.name, c.description, c.category, c.cover_image, c.member_count, c.status, c.post_count, c.is_public, c.created_by, c.settings, c.created_at, c.updated_at,
    EXISTS(SELECT 1 FROM community_members cm2 WHERE cm2.community_id = c.id AND cm2.user_id = $1) as is_member,
    (SELECT COUNT(*) FROM community_members cm3 WHERE cm3.community_id = c.id) as actual_member_count
FROM communities c
WHERE c.space_id = $2
  AND (c.name ILIKE $3 OR c.description ILIKE $3 OR c.category ILIKE $3)
  AND (c.is_public = true OR EXISTS(SELECT 1 FROM community_members cm4 WHERE cm4.community_id = c.id AND cm4.user_id = $1))
ORDER BY c.member_count DESC
LIMIT 50
`

type SearchCommunitiesParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
	Name    string    `json:"name"`
}

type SearchCommunitiesRow struct {
	ID                uuid.UUID             `json:"id"`
	SpaceID           uuid.UUID             `json:"space_id"`
	Name              string                `json:"name"`
	Description       sql.NullString        `json:"description"`
	Category          string                `json:"category"`
	CoverImage        sql.NullString        `json:"cover_image"`
	MemberCount       sql.NullInt32         `json:"member_count"`
	Status            sql.NullString        `json:"status"`
	PostCount         sql.NullInt32         `json:"post_count"`
	IsPublic          sql.NullBool          `json:"is_public"`
	CreatedBy         uuid.NullUUID         `json:"created_by"`
	Settings          pqtype.NullRawMessage `json:"settings"`
	CreatedAt         sql.NullTime          `json:"created_at"`
	UpdatedAt         sql.NullTime          `json:"updated_at"`
	IsMember          bool                  `json:"is_member"`
	ActualMemberCount int64                 `json:"actual_member_count"`
}

func (q *Queries) SearchCommunities(ctx context.Context, arg SearchCommunitiesParams) ([]SearchCommunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCommunities, arg.UserID, arg.SpaceID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCommunitiesRow{}
	for rows.Next() {
		var i SearchCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.CoverImage,
			&i.MemberCount,
			&i.Status,
			&i.PostCount,
			&i.IsPublic,
			&i.CreatedBy,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMember,
			&i.ActualMemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommunity = `-- name: UpdateCommunity :one
UPDATE communities 
SET 
    name = $1,
    description = $2,
    cover_image = $3,
    category = $4,
    is_public = $5,
    settings = $6,
    updated_at = NOW()
WHERE id = $7
RETURNING id, space_id, name, description, category, cover_image, member_count, status, post_count, is_public, created_by, settings, created_at, updated_at
`

type UpdateCommunityParams struct {
	Name        string                `json:"name"`
	Description sql.NullString        `json:"description"`
	CoverImage  sql.NullString        `json:"cover_image"`
	Category    string                `json:"category"`
	IsPublic    sql.NullBool          `json:"is_public"`
	Settings    pqtype.NullRawMessage `json:"settings"`
	ID          uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateCommunity(ctx context.Context, arg UpdateCommunityParams) (Community, error) {
	row := q.db.QueryRowContext(ctx, updateCommunity,
		arg.Name,
		arg.Description,
		arg.CoverImage,
		arg.Category,
		arg.IsPublic,
		arg.Settings,
		arg.ID,
	)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.CoverImage,
		&i.MemberCount,
		&i.Status,
		&i.PostCount,
		&i.IsPublic,
		&i.CreatedBy,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCommunityStats = `-- name: UpdateCommunityStats :exec
UPDATE communities 
SET 
    member_count = (SELECT COUNT(*) FROM community_members cm5 WHERE cm5.community_id = $1),
    post_count = (SELECT COUNT(*) FROM posts WHERE community_id = $1 AND status = 'active'),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateCommunityStats(ctx context.Context, communityID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateCommunityStats, communityID)
	return err
}

const updateCommunityStatus = `-- name: UpdateCommunityStatus :one
UPDATE communities
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, space_id, name, description, category, cover_image, member_count, status, post_count, is_public, created_by, settings, created_at, updated_at
`

type UpdateCommunityStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateCommunityStatus(ctx context.Context, arg UpdateCommunityStatusParams) (Community, error) {
	row := q.db.QueryRowContext(ctx, updateCommunityStatus, arg.Status, arg.ID)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.CoverImage,
		&i.MemberCount,
		&i.Status,
		&i.PostCount,
		&i.IsPublic,
		&i.CreatedBy,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
