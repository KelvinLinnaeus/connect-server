// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const advancedSearchPosts = `-- name: AdvancedSearchPosts :many
SELECT 
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    u.username,
    u.full_name,
    u.avatar as author_avatar,
    c.name as community_name,
    g.name as group_name,
    ts_rank_cd(
        to_tsvector('english', p.content || ' ' || COALESCE(array_to_string(p.tags, ' '), '')),
        plainto_tsquery('english', $1)
    ) as relevance_score
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN communities c ON p.community_id = c.id
LEFT JOIN groups g ON p.group_id = g.id
WHERE p.space_id = $2
  AND p.status = 'active'
  AND (
    to_tsvector('english', p.content || ' ' || COALESCE(array_to_string(p.tags, ' '), '')) 
    @@ plainto_tsquery('english', $1)
    OR p.content ILIKE '%' || $1 || '%'
    OR p.tags @> ARRAY[$1]::text[]
  )
ORDER BY relevance_score DESC, p.created_at DESC
LIMIT $3 OFFSET $4
`

type AdvancedSearchPostsParams struct {
	PlaintoTsquery string    `json:"plainto_tsquery"`
	SpaceID        uuid.UUID `json:"space_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type AdvancedSearchPostsRow struct {
	ID             uuid.UUID             `json:"id"`
	AuthorID       uuid.UUID             `json:"author_id"`
	SpaceID        uuid.UUID             `json:"space_id"`
	CommunityID    uuid.NullUUID         `json:"community_id"`
	GroupID        uuid.NullUUID         `json:"group_id"`
	ParentPostID   uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID   uuid.NullUUID         `json:"quoted_post_id"`
	Content        string                `json:"content"`
	Media          pqtype.NullRawMessage `json:"media"`
	Tags           []string              `json:"tags"`
	LikesCount     sql.NullInt32         `json:"likes_count"`
	CommentsCount  sql.NullInt32         `json:"comments_count"`
	RepostsCount   sql.NullInt32         `json:"reposts_count"`
	QuotesCount    sql.NullInt32         `json:"quotes_count"`
	ViewsCount     sql.NullInt32         `json:"views_count"`
	IsPinned       sql.NullBool          `json:"is_pinned"`
	Visibility     sql.NullString        `json:"visibility"`
	Status         sql.NullString        `json:"status"`
	CreatedAt      sql.NullTime          `json:"created_at"`
	UpdatedAt      sql.NullTime          `json:"updated_at"`
	Username       string                `json:"username"`
	FullName       string                `json:"full_name"`
	AuthorAvatar   sql.NullString        `json:"author_avatar"`
	CommunityName  sql.NullString        `json:"community_name"`
	GroupName      sql.NullString        `json:"group_name"`
	RelevanceScore float32               `json:"relevance_score"`
}

func (q *Queries) AdvancedSearchPosts(ctx context.Context, arg AdvancedSearchPostsParams) ([]AdvancedSearchPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, advancedSearchPosts,
		arg.PlaintoTsquery,
		arg.SpaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdvancedSearchPostsRow{}
	for rows.Next() {
		var i AdvancedSearchPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.CommunityName,
			&i.GroupName,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (post_id, author_id, parent_comment_id, content)
VALUES ($1, $2, $3, $4)
RETURNING id, post_id, author_id, parent_comment_id, content, likes_count, status, created_at, updated_at
`

type CreateCommentParams struct {
	PostID          uuid.UUID     `json:"post_id"`
	AuthorID        uuid.UUID     `json:"author_id"`
	ParentCommentID uuid.NullUUID `json:"parent_comment_id"`
	Content         string        `json:"content"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.AuthorID,
		arg.ParentCommentID,
		arg.Content,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.AuthorID,
		&i.ParentCommentID,
		&i.Content,
		&i.LikesCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one

INSERT INTO posts (
    author_id, space_id, community_id, group_id, parent_post_id, quoted_post_id,
    content, media, tags, visibility
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, author_id, space_id, community_id, group_id, parent_post_id, quoted_post_id, content, media, tags, likes_count, comments_count, reposts_count, quotes_count, views_count, is_pinned, visibility, status, created_at, updated_at
`

type CreatePostParams struct {
	AuthorID     uuid.UUID             `json:"author_id"`
	SpaceID      uuid.UUID             `json:"space_id"`
	CommunityID  uuid.NullUUID         `json:"community_id"`
	GroupID      uuid.NullUUID         `json:"group_id"`
	ParentPostID uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID uuid.NullUUID         `json:"quoted_post_id"`
	Content      string                `json:"content"`
	Media        pqtype.NullRawMessage `json:"media"`
	Tags         []string              `json:"tags"`
	Visibility   sql.NullString        `json:"visibility"`
}

// Posts and Social Interactions Queries
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.AuthorID,
		arg.SpaceID,
		arg.CommunityID,
		arg.GroupID,
		arg.ParentPostID,
		arg.QuotedPostID,
		arg.Content,
		arg.Media,
		pq.Array(arg.Tags),
		arg.Visibility,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.SpaceID,
		&i.CommunityID,
		&i.GroupID,
		&i.ParentPostID,
		&i.QuotedPostID,
		&i.Content,
		&i.Media,
		pq.Array(&i.Tags),
		&i.LikesCount,
		&i.CommentsCount,
		&i.RepostsCount,
		&i.QuotesCount,
		&i.ViewsCount,
		&i.IsPinned,
		&i.Visibility,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRepost = `-- name: CreateRepost :one
INSERT INTO posts (author_id, space_id, quoted_post_id, content, visibility)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, author_id, space_id, community_id, group_id, parent_post_id, quoted_post_id, content, media, tags, likes_count, comments_count, reposts_count, quotes_count, views_count, is_pinned, visibility, status, created_at, updated_at
`

type CreateRepostParams struct {
	AuthorID     uuid.UUID      `json:"author_id"`
	SpaceID      uuid.UUID      `json:"space_id"`
	QuotedPostID uuid.NullUUID  `json:"quoted_post_id"`
	Content      string         `json:"content"`
	Visibility   sql.NullString `json:"visibility"`
}

func (q *Queries) CreateRepost(ctx context.Context, arg CreateRepostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createRepost,
		arg.AuthorID,
		arg.SpaceID,
		arg.QuotedPostID,
		arg.Content,
		arg.Visibility,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.SpaceID,
		&i.CommunityID,
		&i.GroupID,
		&i.ParentPostID,
		&i.QuotedPostID,
		&i.Content,
		&i.Media,
		pq.Array(&i.Tags),
		&i.LikesCount,
		&i.CommentsCount,
		&i.RepostsCount,
		&i.QuotesCount,
		&i.ViewsCount,
		&i.IsPinned,
		&i.Visibility,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
UPDATE posts SET status = 'removed', updated_at = NOW() WHERE id = $1 AND author_id = $2
`

type DeletePostParams struct {
	ID       uuid.UUID `json:"id"`
	AuthorID uuid.UUID `json:"author_id"`
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) error {
	_, err := q.db.ExecContext(ctx, deletePost, arg.ID, arg.AuthorID)
	return err
}

const getCommunityPosts = `-- name: GetCommunityPosts :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    EXISTS(SELECT 1 FROM likes l6 WHERE l6.post_id = p.id AND l6.user_id = $1) as is_liked
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.community_id = $2 AND p.status = 'active'
ORDER BY p.is_pinned DESC, p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetCommunityPostsParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	CommunityID uuid.NullUUID `json:"community_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

type GetCommunityPostsRow struct {
	ID            uuid.UUID             `json:"id"`
	AuthorID      uuid.UUID             `json:"author_id"`
	SpaceID       uuid.UUID             `json:"space_id"`
	CommunityID   uuid.NullUUID         `json:"community_id"`
	GroupID       uuid.NullUUID         `json:"group_id"`
	ParentPostID  uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID  uuid.NullUUID         `json:"quoted_post_id"`
	Content       string                `json:"content"`
	Media         pqtype.NullRawMessage `json:"media"`
	Tags          []string              `json:"tags"`
	LikesCount    sql.NullInt32         `json:"likes_count"`
	CommentsCount sql.NullInt32         `json:"comments_count"`
	RepostsCount  sql.NullInt32         `json:"reposts_count"`
	QuotesCount   sql.NullInt32         `json:"quotes_count"`
	ViewsCount    sql.NullInt32         `json:"views_count"`
	IsPinned      sql.NullBool          `json:"is_pinned"`
	Visibility    sql.NullString        `json:"visibility"`
	Status        sql.NullString        `json:"status"`
	CreatedAt     sql.NullTime          `json:"created_at"`
	UpdatedAt     sql.NullTime          `json:"updated_at"`
	Username      interface{}           `json:"username"`
	FullName      interface{}           `json:"full_name"`
	AuthorAvatar  sql.NullString        `json:"author_avatar"`
	IsLiked       bool                  `json:"is_liked"`
}

func (q *Queries) GetCommunityPosts(ctx context.Context, arg GetCommunityPostsParams) ([]GetCommunityPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommunityPosts,
		arg.UserID,
		arg.CommunityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommunityPostsRow{}
	for rows.Next() {
		var i GetCommunityPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupPosts = `-- name: GetGroupPosts :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    EXISTS(SELECT 1 FROM likes l7 WHERE l7.post_id = p.id AND l7.user_id = $1) as is_liked
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.group_id = $2 AND p.status = 'active'
ORDER BY p.is_pinned DESC, p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetGroupPostsParams struct {
	UserID  uuid.UUID     `json:"user_id"`
	GroupID uuid.NullUUID `json:"group_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

type GetGroupPostsRow struct {
	ID            uuid.UUID             `json:"id"`
	AuthorID      uuid.UUID             `json:"author_id"`
	SpaceID       uuid.UUID             `json:"space_id"`
	CommunityID   uuid.NullUUID         `json:"community_id"`
	GroupID       uuid.NullUUID         `json:"group_id"`
	ParentPostID  uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID  uuid.NullUUID         `json:"quoted_post_id"`
	Content       string                `json:"content"`
	Media         pqtype.NullRawMessage `json:"media"`
	Tags          []string              `json:"tags"`
	LikesCount    sql.NullInt32         `json:"likes_count"`
	CommentsCount sql.NullInt32         `json:"comments_count"`
	RepostsCount  sql.NullInt32         `json:"reposts_count"`
	QuotesCount   sql.NullInt32         `json:"quotes_count"`
	ViewsCount    sql.NullInt32         `json:"views_count"`
	IsPinned      sql.NullBool          `json:"is_pinned"`
	Visibility    sql.NullString        `json:"visibility"`
	Status        sql.NullString        `json:"status"`
	CreatedAt     sql.NullTime          `json:"created_at"`
	UpdatedAt     sql.NullTime          `json:"updated_at"`
	Username      interface{}           `json:"username"`
	FullName      interface{}           `json:"full_name"`
	AuthorAvatar  sql.NullString        `json:"author_avatar"`
	IsLiked       bool                  `json:"is_liked"`
}

func (q *Queries) GetGroupPosts(ctx context.Context, arg GetGroupPostsParams) ([]GetGroupPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupPosts,
		arg.UserID,
		arg.GroupID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupPostsRow{}
	for rows.Next() {
		var i GetGroupPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByID = `-- name: GetPostByID :one
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    u.verified as author_verified,
    c.name as community_name,
    c.id as community_id,
    g.name as group_name,
    g.id as group_id,
    qp.content as quoted_content,
    qp.author_id as quoted_author_id,
    COALESCE(NULLIF(qu.username, ''), 'user_' || SUBSTRING(qu.id::text, 1, 8)) as quoted_username,
    COALESCE(NULLIF(qu.full_name, ''), 'User') as quoted_full_name,
    EXISTS(SELECT 1 FROM likes l2 WHERE l2.post_id = p.id AND l2.user_id = $1) as is_liked,
    EXISTS(SELECT 1 FROM posts pq2 WHERE pq2.quoted_post_id = p.id AND pq2.author_id = $1) as is_quoted,
    (SELECT COUNT(*) FROM likes l3 WHERE l3.post_id = p.id) as actual_likes_count,
    (SELECT COUNT(*) FROM comments c2 WHERE c2.post_id = p.id AND c2.status = 'active') as actual_comments_count,
    (SELECT COUNT(*) FROM posts p2 WHERE p2.quoted_post_id = p.id AND p2.status = 'active') as actual_quotes_count
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN communities c ON p.community_id = c.id
LEFT JOIN groups g ON p.group_id = g.id
LEFT JOIN posts qp ON p.quoted_post_id = qp.id
LEFT JOIN users qu ON qp.author_id = qu.id
WHERE p.id = $2 AND p.status = 'active'
`

type GetPostByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

type GetPostByIDRow struct {
	ID                  uuid.UUID             `json:"id"`
	AuthorID            uuid.UUID             `json:"author_id"`
	SpaceID             uuid.UUID             `json:"space_id"`
	CommunityID         uuid.NullUUID         `json:"community_id"`
	GroupID             uuid.NullUUID         `json:"group_id"`
	ParentPostID        uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID        uuid.NullUUID         `json:"quoted_post_id"`
	Content             string                `json:"content"`
	Media               pqtype.NullRawMessage `json:"media"`
	Tags                []string              `json:"tags"`
	LikesCount          sql.NullInt32         `json:"likes_count"`
	CommentsCount       sql.NullInt32         `json:"comments_count"`
	RepostsCount        sql.NullInt32         `json:"reposts_count"`
	QuotesCount         sql.NullInt32         `json:"quotes_count"`
	ViewsCount          sql.NullInt32         `json:"views_count"`
	IsPinned            sql.NullBool          `json:"is_pinned"`
	Visibility          sql.NullString        `json:"visibility"`
	Status              sql.NullString        `json:"status"`
	CreatedAt           sql.NullTime          `json:"created_at"`
	UpdatedAt           sql.NullTime          `json:"updated_at"`
	Username            interface{}           `json:"username"`
	FullName            interface{}           `json:"full_name"`
	AuthorAvatar        sql.NullString        `json:"author_avatar"`
	AuthorVerified      sql.NullBool          `json:"author_verified"`
	CommunityName       sql.NullString        `json:"community_name"`
	CommunityID_2       uuid.NullUUID         `json:"community_id_2"`
	GroupName           sql.NullString        `json:"group_name"`
	GroupID_2           uuid.NullUUID         `json:"group_id_2"`
	QuotedContent       sql.NullString        `json:"quoted_content"`
	QuotedAuthorID      uuid.NullUUID         `json:"quoted_author_id"`
	QuotedUsername      interface{}           `json:"quoted_username"`
	QuotedFullName      interface{}           `json:"quoted_full_name"`
	IsLiked             bool                  `json:"is_liked"`
	IsQuoted            bool                  `json:"is_quoted"`
	ActualLikesCount    int64                 `json:"actual_likes_count"`
	ActualCommentsCount int64                 `json:"actual_comments_count"`
	ActualQuotesCount   int64                 `json:"actual_quotes_count"`
}

func (q *Queries) GetPostByID(ctx context.Context, arg GetPostByIDParams) (GetPostByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByID, arg.UserID, arg.ID)
	var i GetPostByIDRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.SpaceID,
		&i.CommunityID,
		&i.GroupID,
		&i.ParentPostID,
		&i.QuotedPostID,
		&i.Content,
		&i.Media,
		pq.Array(&i.Tags),
		&i.LikesCount,
		&i.CommentsCount,
		&i.RepostsCount,
		&i.QuotesCount,
		&i.ViewsCount,
		&i.IsPinned,
		&i.Visibility,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.FullName,
		&i.AuthorAvatar,
		&i.AuthorVerified,
		&i.CommunityName,
		&i.CommunityID_2,
		&i.GroupName,
		&i.GroupID_2,
		&i.QuotedContent,
		&i.QuotedAuthorID,
		&i.QuotedUsername,
		&i.QuotedFullName,
		&i.IsLiked,
		&i.IsQuoted,
		&i.ActualLikesCount,
		&i.ActualCommentsCount,
		&i.ActualQuotesCount,
	)
	return i, err
}

const getPostComments = `-- name: GetPostComments :many
WITH RECURSIVE comment_tree AS (
    SELECT 
        c.id, c.post_id, c.author_id, c.parent_comment_id, c.content, c.likes_count, c.status, c.created_at, c.updated_at, 
        u.username,
        u.full_name,
        u.avatar,
        0 as depth,
        ARRAY[c.id] as path
    FROM comments c
    JOIN users u ON c.author_id = u.id
    WHERE c.post_id = $1 AND c.parent_comment_id IS NULL AND c.status = 'active'
    
    UNION ALL
    
    SELECT 
        c.id, c.post_id, c.author_id, c.parent_comment_id, c.content, c.likes_count, c.status, c.created_at, c.updated_at,
        u.username,
        u.full_name,
        u.avatar,
        ct.depth + 1 as depth,
        ct.path || c.id as path
    FROM comments c
    JOIN users u ON c.author_id = u.id
    JOIN comment_tree ct ON c.parent_comment_id = ct.id
    WHERE c.status = 'active'
)
SELECT id, post_id, author_id, parent_comment_id, content, likes_count, status, created_at, updated_at, username, full_name, avatar, depth, path FROM comment_tree
ORDER BY path, created_at
`

type GetPostCommentsRow struct {
	ID              uuid.UUID      `json:"id"`
	PostID          uuid.UUID      `json:"post_id"`
	AuthorID        uuid.UUID      `json:"author_id"`
	ParentCommentID uuid.NullUUID  `json:"parent_comment_id"`
	Content         string         `json:"content"`
	LikesCount      sql.NullInt32  `json:"likes_count"`
	Status          sql.NullString `json:"status"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	Username        string         `json:"username"`
	FullName        string         `json:"full_name"`
	Avatar          sql.NullString `json:"avatar"`
	Depth           int32          `json:"depth"`
	Path            interface{}    `json:"path"`
}

func (q *Queries) GetPostComments(ctx context.Context, postID uuid.UUID) ([]GetPostCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostComments, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostCommentsRow{}
	for rows.Next() {
		var i GetPostCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.AuthorID,
			&i.ParentCommentID,
			&i.Content,
			&i.LikesCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.Depth,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostLikes = `-- name: GetPostLikes :many
SELECT 
    u.id,
    u.username,
    u.full_name,
    u.avatar,
    l.created_at
FROM likes l
JOIN users u ON l.user_id = u.id
WHERE l.post_id = $1 AND u.status = 'active'
ORDER BY l.created_at DESC
`

type GetPostLikesRow struct {
	ID        uuid.UUID      `json:"id"`
	Username  string         `json:"username"`
	FullName  string         `json:"full_name"`
	Avatar    sql.NullString `json:"avatar"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetPostLikes(ctx context.Context, postID uuid.NullUUID) ([]GetPostLikesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostLikes, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostLikesRow{}
	for rows.Next() {
		var i GetPostLikesRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.Avatar,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingPosts = `-- name: GetTrendingPosts :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    (p.likes_count + (p.comments_count * 2) + p.views_count + (p.quotes_count * 3)) as engagement_score
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.space_id = $1
  AND p.status = 'active'
  AND p.created_at >= NOW() - INTERVAL '7 days'
ORDER BY engagement_score DESC, p.created_at DESC
LIMIT 20
`

type GetTrendingPostsRow struct {
	ID              uuid.UUID             `json:"id"`
	AuthorID        uuid.UUID             `json:"author_id"`
	SpaceID         uuid.UUID             `json:"space_id"`
	CommunityID     uuid.NullUUID         `json:"community_id"`
	GroupID         uuid.NullUUID         `json:"group_id"`
	ParentPostID    uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID    uuid.NullUUID         `json:"quoted_post_id"`
	Content         string                `json:"content"`
	Media           pqtype.NullRawMessage `json:"media"`
	Tags            []string              `json:"tags"`
	LikesCount      sql.NullInt32         `json:"likes_count"`
	CommentsCount   sql.NullInt32         `json:"comments_count"`
	RepostsCount    sql.NullInt32         `json:"reposts_count"`
	QuotesCount     sql.NullInt32         `json:"quotes_count"`
	ViewsCount      sql.NullInt32         `json:"views_count"`
	IsPinned        sql.NullBool          `json:"is_pinned"`
	Visibility      sql.NullString        `json:"visibility"`
	Status          sql.NullString        `json:"status"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
	Username        interface{}           `json:"username"`
	FullName        interface{}           `json:"full_name"`
	AuthorAvatar    sql.NullString        `json:"author_avatar"`
	EngagementScore int32                 `json:"engagement_score"`
}

func (q *Queries) GetTrendingPosts(ctx context.Context, spaceID uuid.UUID) ([]GetTrendingPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingPosts, spaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrendingPostsRow{}
	for rows.Next() {
		var i GetTrendingPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingTopics = `-- name: GetTrendingTopics :many
WITH hashtags AS (
  SELECT
    unnest(regexp_matches(content, '#([a-zA-Z0-9_]+)', 'g')) AS tag,
    p.id,
    p.created_at,
    COALESCE(p.likes_count, 0) + COALESCE(p.comments_count, 0) + COALESCE(p.reposts_count, 0) AS engagement
  FROM posts p
  WHERE p.space_id = $1
    AND p.status = 'active'
    AND p.created_at > NOW() - INTERVAL '24 hours'
)
SELECT
  lower(tag) AS id,
  '#' || tag AS name,
  'General' AS category,
  COUNT(DISTINCT id) AS posts_count,
  -- Trend score: posts * avg_engagement * recency_factor
  COUNT(*) * AVG(engagement)::int AS trend_score
FROM hashtags
GROUP BY lower(tag), tag
ORDER BY trend_score DESC
LIMIT $2 OFFSET $3
`

type GetTrendingTopicsParams struct {
	SpaceID uuid.UUID `json:"space_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type GetTrendingTopicsRow struct {
	ID         string      `json:"id"`
	Name       interface{} `json:"name"`
	Category   string      `json:"category"`
	PostsCount int64       `json:"posts_count"`
	TrendScore int32       `json:"trend_score"`
}

func (q *Queries) GetTrendingTopics(ctx context.Context, arg GetTrendingTopicsParams) ([]GetTrendingTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingTopics, arg.SpaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrendingTopicsRow{}
	for rows.Next() {
		var i GetTrendingTopicsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.PostsCount,
			&i.TrendScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFeed = `-- name: GetUserFeed :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    u.verified as author_verified,
    c.name as community_name,
    g.name as group_name,
    EXISTS(SELECT 1 FROM likes l4 WHERE l4.post_id = p.id AND l4.user_id = $1) as is_liked,
    EXISTS(SELECT 1 FROM posts pq3 WHERE pq3.quoted_post_id = p.id AND pq3.author_id = $1) as is_quoted
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN communities c ON p.community_id = c.id
LEFT JOIN groups g ON p.group_id = g.id
WHERE p.space_id = $2
  AND p.status = 'active'
  AND (p.visibility = 'public'
       OR p.author_id = $1
       OR p.author_id IN (SELECT following_id FROM follows WHERE follower_id = $1)
       OR p.community_id IN (SELECT community_id FROM community_members WHERE user_id = $1)
       OR p.group_id IN (SELECT group_id FROM group_members WHERE user_id = $1))
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetUserFeedParams struct {
	UserID  uuid.UUID `json:"user_id"`
	SpaceID uuid.UUID `json:"space_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type GetUserFeedRow struct {
	ID             uuid.UUID             `json:"id"`
	AuthorID       uuid.UUID             `json:"author_id"`
	SpaceID        uuid.UUID             `json:"space_id"`
	CommunityID    uuid.NullUUID         `json:"community_id"`
	GroupID        uuid.NullUUID         `json:"group_id"`
	ParentPostID   uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID   uuid.NullUUID         `json:"quoted_post_id"`
	Content        string                `json:"content"`
	Media          pqtype.NullRawMessage `json:"media"`
	Tags           []string              `json:"tags"`
	LikesCount     sql.NullInt32         `json:"likes_count"`
	CommentsCount  sql.NullInt32         `json:"comments_count"`
	RepostsCount   sql.NullInt32         `json:"reposts_count"`
	QuotesCount    sql.NullInt32         `json:"quotes_count"`
	ViewsCount     sql.NullInt32         `json:"views_count"`
	IsPinned       sql.NullBool          `json:"is_pinned"`
	Visibility     sql.NullString        `json:"visibility"`
	Status         sql.NullString        `json:"status"`
	CreatedAt      sql.NullTime          `json:"created_at"`
	UpdatedAt      sql.NullTime          `json:"updated_at"`
	Username       interface{}           `json:"username"`
	FullName       interface{}           `json:"full_name"`
	AuthorAvatar   sql.NullString        `json:"author_avatar"`
	AuthorVerified sql.NullBool          `json:"author_verified"`
	CommunityName  sql.NullString        `json:"community_name"`
	GroupName      sql.NullString        `json:"group_name"`
	IsLiked        bool                  `json:"is_liked"`
	IsQuoted       bool                  `json:"is_quoted"`
}

func (q *Queries) GetUserFeed(ctx context.Context, arg GetUserFeedParams) ([]GetUserFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserFeed,
		arg.UserID,
		arg.SpaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFeedRow{}
	for rows.Next() {
		var i GetUserFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.AuthorVerified,
			&i.CommunityName,
			&i.GroupName,
			&i.IsLiked,
			&i.IsQuoted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLikedPosts = `-- name: GetUserLikedPosts :many
SELECT 
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    u.username,
    u.full_name,
    u.avatar as author_avatar
FROM posts p
JOIN likes l ON p.id = l.post_id
JOIN users u ON p.author_id = u.id
WHERE l.user_id = $1 AND p.status = 'active'
ORDER BY l.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserLikedPostsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetUserLikedPostsRow struct {
	ID            uuid.UUID             `json:"id"`
	AuthorID      uuid.UUID             `json:"author_id"`
	SpaceID       uuid.UUID             `json:"space_id"`
	CommunityID   uuid.NullUUID         `json:"community_id"`
	GroupID       uuid.NullUUID         `json:"group_id"`
	ParentPostID  uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID  uuid.NullUUID         `json:"quoted_post_id"`
	Content       string                `json:"content"`
	Media         pqtype.NullRawMessage `json:"media"`
	Tags          []string              `json:"tags"`
	LikesCount    sql.NullInt32         `json:"likes_count"`
	CommentsCount sql.NullInt32         `json:"comments_count"`
	RepostsCount  sql.NullInt32         `json:"reposts_count"`
	QuotesCount   sql.NullInt32         `json:"quotes_count"`
	ViewsCount    sql.NullInt32         `json:"views_count"`
	IsPinned      sql.NullBool          `json:"is_pinned"`
	Visibility    sql.NullString        `json:"visibility"`
	Status        sql.NullString        `json:"status"`
	CreatedAt     sql.NullTime          `json:"created_at"`
	UpdatedAt     sql.NullTime          `json:"updated_at"`
	Username      string                `json:"username"`
	FullName      string                `json:"full_name"`
	AuthorAvatar  sql.NullString        `json:"author_avatar"`
}

func (q *Queries) GetUserLikedPosts(ctx context.Context, arg GetUserLikedPostsParams) ([]GetUserLikedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserLikedPosts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLikedPostsRow{}
	for rows.Next() {
		var i GetUserLikedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPosts = `-- name: GetUserPosts :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    c.name as community_name,
    g.name as group_name,
    EXISTS(SELECT 1 FROM likes l5 WHERE l5.post_id = p.id AND l5.user_id = $1) as is_liked
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN communities c ON p.community_id = c.id
LEFT JOIN groups g ON p.group_id = g.id
WHERE p.author_id = $1 AND p.status = 'active'
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserPostsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetUserPostsRow struct {
	ID            uuid.UUID             `json:"id"`
	AuthorID      uuid.UUID             `json:"author_id"`
	SpaceID       uuid.UUID             `json:"space_id"`
	CommunityID   uuid.NullUUID         `json:"community_id"`
	GroupID       uuid.NullUUID         `json:"group_id"`
	ParentPostID  uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID  uuid.NullUUID         `json:"quoted_post_id"`
	Content       string                `json:"content"`
	Media         pqtype.NullRawMessage `json:"media"`
	Tags          []string              `json:"tags"`
	LikesCount    sql.NullInt32         `json:"likes_count"`
	CommentsCount sql.NullInt32         `json:"comments_count"`
	RepostsCount  sql.NullInt32         `json:"reposts_count"`
	QuotesCount   sql.NullInt32         `json:"quotes_count"`
	ViewsCount    sql.NullInt32         `json:"views_count"`
	IsPinned      sql.NullBool          `json:"is_pinned"`
	Visibility    sql.NullString        `json:"visibility"`
	Status        sql.NullString        `json:"status"`
	CreatedAt     sql.NullTime          `json:"created_at"`
	UpdatedAt     sql.NullTime          `json:"updated_at"`
	Username      interface{}           `json:"username"`
	FullName      interface{}           `json:"full_name"`
	AuthorAvatar  sql.NullString        `json:"author_avatar"`
	CommunityName sql.NullString        `json:"community_name"`
	GroupName     sql.NullString        `json:"group_name"`
	IsLiked       bool                  `json:"is_liked"`
}

func (q *Queries) GetUserPosts(ctx context.Context, arg GetUserPostsParams) ([]GetUserPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPosts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPostsRow{}
	for rows.Next() {
		var i GetUserPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.CommunityName,
			&i.GroupName,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementPostViews = `-- name: IncrementPostViews :exec
UPDATE posts SET views_count = views_count + 1 WHERE id = $1
`

func (q *Queries) IncrementPostViews(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementPostViews, id)
	return err
}

const pinPost = `-- name: PinPost :exec
UPDATE posts SET is_pinned = $1, updated_at = NOW() WHERE id = $2
`

type PinPostParams struct {
	IsPinned sql.NullBool `json:"is_pinned"`
	ID       uuid.UUID    `json:"id"`
}

func (q *Queries) PinPost(ctx context.Context, arg PinPostParams) error {
	_, err := q.db.ExecContext(ctx, pinPost, arg.IsPinned, arg.ID)
	return err
}

const searchPosts = `-- name: SearchPosts :many
SELECT
    p.id, p.author_id, p.space_id, p.community_id, p.group_id, p.parent_post_id, p.quoted_post_id, p.content, p.media, p.tags, p.likes_count, p.comments_count, p.reposts_count, p.quotes_count, p.views_count, p.is_pinned, p.visibility, p.status, p.created_at, p.updated_at,
    COALESCE(NULLIF(u.username, ''), 'user_' || SUBSTRING(u.id::text, 1, 8)) as username,
    COALESCE(NULLIF(u.full_name, ''), 'User') as full_name,
    u.avatar as author_avatar,
    c.name as community_name,
    g.name as group_name,
    ts_rank_cd(to_tsvector('english', p.content), plainto_tsquery('english', $2)) as rank
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN communities c ON p.community_id = c.id
LEFT JOIN groups g ON p.group_id = g.id
WHERE p.space_id = $1
  AND p.status = 'active'
  AND (p.content ILIKE $3 OR p.tags @> ARRAY[$2]::text[] OR to_tsvector('english', p.content) @@ plainto_tsquery('english', $2))
ORDER BY rank DESC, p.created_at DESC
LIMIT $4 OFFSET $5
`

type SearchPostsParams struct {
	SpaceID        uuid.UUID `json:"space_id"`
	PlaintoTsquery string    `json:"plainto_tsquery"`
	Content        string    `json:"content"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type SearchPostsRow struct {
	ID            uuid.UUID             `json:"id"`
	AuthorID      uuid.UUID             `json:"author_id"`
	SpaceID       uuid.UUID             `json:"space_id"`
	CommunityID   uuid.NullUUID         `json:"community_id"`
	GroupID       uuid.NullUUID         `json:"group_id"`
	ParentPostID  uuid.NullUUID         `json:"parent_post_id"`
	QuotedPostID  uuid.NullUUID         `json:"quoted_post_id"`
	Content       string                `json:"content"`
	Media         pqtype.NullRawMessage `json:"media"`
	Tags          []string              `json:"tags"`
	LikesCount    sql.NullInt32         `json:"likes_count"`
	CommentsCount sql.NullInt32         `json:"comments_count"`
	RepostsCount  sql.NullInt32         `json:"reposts_count"`
	QuotesCount   sql.NullInt32         `json:"quotes_count"`
	ViewsCount    sql.NullInt32         `json:"views_count"`
	IsPinned      sql.NullBool          `json:"is_pinned"`
	Visibility    sql.NullString        `json:"visibility"`
	Status        sql.NullString        `json:"status"`
	CreatedAt     sql.NullTime          `json:"created_at"`
	UpdatedAt     sql.NullTime          `json:"updated_at"`
	Username      interface{}           `json:"username"`
	FullName      interface{}           `json:"full_name"`
	AuthorAvatar  sql.NullString        `json:"author_avatar"`
	CommunityName sql.NullString        `json:"community_name"`
	GroupName     sql.NullString        `json:"group_name"`
	Rank          float32               `json:"rank"`
}

func (q *Queries) SearchPosts(ctx context.Context, arg SearchPostsParams) ([]SearchPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPosts,
		arg.SpaceID,
		arg.PlaintoTsquery,
		arg.Content,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPostsRow{}
	for rows.Next() {
		var i SearchPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.SpaceID,
			&i.CommunityID,
			&i.GroupID,
			&i.ParentPostID,
			&i.QuotedPostID,
			&i.Content,
			&i.Media,
			pq.Array(&i.Tags),
			&i.LikesCount,
			&i.CommentsCount,
			&i.RepostsCount,
			&i.QuotesCount,
			&i.ViewsCount,
			&i.IsPinned,
			&i.Visibility,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FullName,
			&i.AuthorAvatar,
			&i.CommunityName,
			&i.GroupName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCommentLike = `-- name: ToggleCommentLike :one
INSERT INTO likes (user_id, comment_id) 
VALUES ($1, $2)
ON CONFLICT (user_id, comment_id) 
DO NOTHING
RETURNING (xmax = 0) as liked
`

type ToggleCommentLikeParams struct {
	UserID    uuid.UUID     `json:"user_id"`
	CommentID uuid.NullUUID `json:"comment_id"`
}

func (q *Queries) ToggleCommentLike(ctx context.Context, arg ToggleCommentLikeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, toggleCommentLike, arg.UserID, arg.CommentID)
	var liked bool
	err := row.Scan(&liked)
	return liked, err
}

const togglePostLike = `-- name: TogglePostLike :one
WITH like_action AS (
    INSERT INTO likes (user_id, post_id) 
    VALUES ($1, $2)
    ON CONFLICT (user_id, post_id) 
    DO NOTHING
    RETURNING true as liked
)
UPDATE posts 
SET likes_count = likes_count + 
    CASE 
        WHEN EXISTS (SELECT 1 FROM like_action) THEN 1 
        ELSE -1 
    END
WHERE posts.id = $2
RETURNING likes_count
`

type TogglePostLikeParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) TogglePostLike(ctx context.Context, arg TogglePostLikeParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, togglePostLike, arg.UserID, arg.ID)
	var likes_count sql.NullInt32
	err := row.Scan(&likes_count)
	return likes_count, err
}
