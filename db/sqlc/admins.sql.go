// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admins.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const adminCreateUser = `-- name: AdminCreateUser :one

INSERT INTO users (
    space_id, username, email, password, full_name, roles, status
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type AdminCreateUserParams struct {
	SpaceID  uuid.UUID      `json:"space_id"`
	Username string         `json:"username"`
	Email    string         `json:"email"`
	Password string         `json:"password"`
	FullName string         `json:"full_name"`
	Roles    []string       `json:"roles"`
	Status   sql.NullString `json:"status"`
}

// Additional Admin User Management Queries
func (q *Queries) AdminCreateUser(ctx context.Context, arg AdminCreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, adminCreateUser,
		arg.SpaceID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.FullName,
		pq.Array(arg.Roles),
		arg.Status,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const adminUpdateUser = `-- name: AdminUpdateUser :one
UPDATE users
SET
    full_name = COALESCE($1, full_name),
    email = COALESCE($2, email),
    roles = COALESCE($3, roles),
    status = COALESCE($4, status),
    department = COALESCE($5, department),
    level = COALESCE($6, level),
    verified = COALESCE($7, verified),
    updated_at = NOW()
WHERE id = $8
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type AdminUpdateUserParams struct {
	FullName   sql.NullString `json:"full_name"`
	Email      sql.NullString `json:"email"`
	Roles      []string       `json:"roles"`
	Status     sql.NullString `json:"status"`
	Department sql.NullString `json:"department"`
	Level      sql.NullString `json:"level"`
	Verified   sql.NullBool   `json:"verified"`
	UserID     uuid.UUID      `json:"user_id"`
}

func (q *Queries) AdminUpdateUser(ctx context.Context, arg AdminUpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, adminUpdateUser,
		arg.FullName,
		arg.Email,
		pq.Array(arg.Roles),
		arg.Status,
		arg.Department,
		arg.Level,
		arg.Verified,
		arg.UserID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const checkAdminPermission = `-- name: CheckAdminPermission :one
SELECT EXISTS(
    SELECT 1 FROM users
    WHERE id = $1
    AND status = 'active'
    AND roles && ARRAY['admin', 'super_admin']::text[]
) as has_permission
`

func (q *Queries) CheckAdminPermission(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAdminPermission, id)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const createAuditLog = `-- name: CreateAuditLog :one

INSERT INTO audit_logs (
    admin_user_id,
    action,
    resource_type,
    resource_id,
    details,
    ip_address,
    user_agent
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, admin_user_id, action, resource_type, resource_id, details, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	AdminUserID  uuid.UUID             `json:"admin_user_id"`
	Action       string                `json:"action"`
	ResourceType string                `json:"resource_type"`
	ResourceID   uuid.NullUUID         `json:"resource_id"`
	Details      pqtype.NullRawMessage `json:"details"`
	IpAddress    pqtype.Inet           `json:"ip_address"`
	UserAgent    sql.NullString        `json:"user_agent"`
}

// Audit Logs Queries
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.AdminUserID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Details,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createContentReport = `-- name: CreateContentReport :one

INSERT INTO reports (
    space_id,
    reporter_id,
    content_type,
    content_id,
    reason,
    description,
    status,
    priority
) VALUES ($1, $2, $3, $4, $5, $6, 'pending', 'medium')
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type CreateContentReportParams struct {
	SpaceID     uuid.UUID      `json:"space_id"`
	ReporterID  uuid.UUID      `json:"reporter_id"`
	ContentType string         `json:"content_type"`
	ContentID   uuid.UUID      `json:"content_id"`
	Reason      string         `json:"reason"`
	Description sql.NullString `json:"description"`
}

// Content Reports Queries
// Note: Uses existing 'reports' table from migration 008
func (q *Queries) CreateContentReport(ctx context.Context, arg CreateContentReportParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, createContentReport,
		arg.SpaceID,
		arg.ReporterID,
		arg.ContentType,
		arg.ContentID,
		arg.Reason,
		arg.Description,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSpaceActivity = `-- name: CreateSpaceActivity :one

INSERT INTO space_activities (
    space_id,
    activity_type,
    actor_id,
    actor_name,
    description,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, space_id, activity_type, actor_id, actor_name, description, metadata, created_at
`

type CreateSpaceActivityParams struct {
	SpaceID      uuid.UUID             `json:"space_id"`
	ActivityType string                `json:"activity_type"`
	ActorID      uuid.NullUUID         `json:"actor_id"`
	ActorName    sql.NullString        `json:"actor_name"`
	Description  string                `json:"description"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
}

// Space Activities Queries
func (q *Queries) CreateSpaceActivity(ctx context.Context, arg CreateSpaceActivityParams) (SpaceActivity, error) {
	row := q.db.QueryRowContext(ctx, createSpaceActivity,
		arg.SpaceID,
		arg.ActivityType,
		arg.ActorID,
		arg.ActorName,
		arg.Description,
		arg.Metadata,
	)
	var i SpaceActivity
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ActivityType,
		&i.ActorID,
		&i.ActorName,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createUserSuspension = `-- name: CreateUserSuspension :one

INSERT INTO user_suspensions (
    user_id,
    suspended_by,
    reason,
    notes,
    suspended_until,
    is_permanent
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, suspended_by, reason, notes, suspended_at, suspended_until, is_permanent, created_at
`

type CreateUserSuspensionParams struct {
	UserID         uuid.UUID      `json:"user_id"`
	SuspendedBy    uuid.UUID      `json:"suspended_by"`
	Reason         string         `json:"reason"`
	Notes          sql.NullString `json:"notes"`
	SuspendedUntil sql.NullTime   `json:"suspended_until"`
	IsPermanent    bool           `json:"is_permanent"`
}

// User Suspension Queries
func (q *Queries) CreateUserSuspension(ctx context.Context, arg CreateUserSuspensionParams) (UserSuspension, error) {
	row := q.db.QueryRowContext(ctx, createUserSuspension,
		arg.UserID,
		arg.SuspendedBy,
		arg.Reason,
		arg.Notes,
		arg.SuspendedUntil,
		arg.IsPermanent,
	)
	var i UserSuspension
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SuspendedBy,
		&i.Reason,
		&i.Notes,
		&i.SuspendedAt,
		&i.SuspendedUntil,
		&i.IsPermanent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSystemSetting = `-- name: DeleteSystemSetting :exec
DELETE FROM system_settings
WHERE key = $1
`

func (q *Queries) DeleteSystemSetting(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteSystemSetting, key)
	return err
}

const getActiveSuspension = `-- name: GetActiveSuspension :one
SELECT id, user_id, suspended_by, reason, notes, suspended_at, suspended_until, is_permanent, created_at FROM user_suspensions
WHERE user_id = $1
AND (suspended_until IS NULL OR suspended_until > NOW())
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveSuspension(ctx context.Context, userID uuid.UUID) (UserSuspension, error) {
	row := q.db.QueryRowContext(ctx, getActiveSuspension, userID)
	var i UserSuspension
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SuspendedBy,
		&i.Reason,
		&i.Notes,
		&i.SuspendedAt,
		&i.SuspendedUntil,
		&i.IsPermanent,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityStats = `-- name: GetActivityStats :one
SELECT
    COUNT(*) FILTER (WHERE activity_type = 'user_joined') as users_joined,
    COUNT(*) FILTER (WHERE activity_type = 'post_created') as posts_created,
    COUNT(*) FILTER (WHERE activity_type = 'community_created') as communities_created,
    COUNT(*) FILTER (WHERE activity_type = 'group_created') as groups_created,
    COUNT(*) FILTER (WHERE activity_type = 'event_created') as events_created
FROM space_activities
WHERE space_id = $1
AND created_at >= $2
`

type GetActivityStatsParams struct {
	SpaceID   uuid.UUID `json:"space_id"`
	CreatedAt time.Time `json:"created_at"`
}

type GetActivityStatsRow struct {
	UsersJoined        int64 `json:"users_joined"`
	PostsCreated       int64 `json:"posts_created"`
	CommunitiesCreated int64 `json:"communities_created"`
	GroupsCreated      int64 `json:"groups_created"`
	EventsCreated      int64 `json:"events_created"`
}

func (q *Queries) GetActivityStats(ctx context.Context, arg GetActivityStatsParams) (GetActivityStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getActivityStats, arg.SpaceID, arg.CreatedAt)
	var i GetActivityStatsRow
	err := row.Scan(
		&i.UsersJoined,
		&i.PostsCreated,
		&i.CommunitiesCreated,
		&i.GroupsCreated,
		&i.EventsCreated,
	)
	return i, err
}

const getAdminDashboardStats = `-- name: GetAdminDashboardStats :one

SELECT
    (SELECT COUNT(*) FROM users u WHERE u.space_id = $1) AS total_users,
    (SELECT COUNT(*) FROM users u WHERE u.space_id = $1 AND u.created_at >= NOW() - INTERVAL '30 days') AS new_users_month,
    (SELECT COUNT(*) FROM posts p WHERE p.space_id = $1 AND p.status = 'active') AS total_posts,
    (SELECT COUNT(*) FROM communities c WHERE c.space_id = $1) AS total_communities,
    (SELECT COUNT(*) FROM groups g WHERE g.space_id = $1) AS total_groups,
    (SELECT COUNT(*) FROM reports r WHERE r.space_id = $1 AND r.status = 'pending') AS pending_reports,
    (SELECT COUNT(*) FROM user_suspensions us JOIN users u ON us.user_id = u.id WHERE u.space_id = $1 AND us.created_at >= NOW() - INTERVAL '30 days') AS suspensions_month
`

type GetAdminDashboardStatsRow struct {
	TotalUsers       int64 `json:"total_users"`
	NewUsersMonth    int64 `json:"new_users_month"`
	TotalPosts       int64 `json:"total_posts"`
	TotalCommunities int64 `json:"total_communities"`
	TotalGroups      int64 `json:"total_groups"`
	PendingReports   int64 `json:"pending_reports"`
	SuspensionsMonth int64 `json:"suspensions_month"`
}

// Admin Dashboard Analytics Queries
func (q *Queries) GetAdminDashboardStats(ctx context.Context, spaceID uuid.UUID) (GetAdminDashboardStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminDashboardStats, spaceID)
	var i GetAdminDashboardStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.NewUsersMonth,
		&i.TotalPosts,
		&i.TotalCommunities,
		&i.TotalGroups,
		&i.PendingReports,
		&i.SuspensionsMonth,
	)
	return i, err
}

const getAllAdminUsers = `-- name: GetAllAdminUsers :many

SELECT
    u.id,
    u.username,
    u.email,
    u.full_name,
    u.avatar,
    u.roles,
    u.status,
    u.created_at,
    u.updated_at
FROM users u
WHERE
    (u.roles && ARRAY['admin', 'super_admin']::text[])
    AND (u.status = $1 OR $1 = '')
ORDER BY u.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllAdminUsersParams struct {
	Status sql.NullString `json:"status"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

type GetAllAdminUsersRow struct {
	ID        uuid.UUID      `json:"id"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
	FullName  string         `json:"full_name"`
	Avatar    sql.NullString `json:"avatar"`
	Roles     []string       `json:"roles"`
	Status    sql.NullString `json:"status"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

// Admin User Management Queries
// Note: Admin users are managed via users table with roles field
func (q *Queries) GetAllAdminUsers(ctx context.Context, arg GetAllAdminUsersParams) ([]GetAllAdminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAdminUsers, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAdminUsersRow{}
	for rows.Next() {
		var i GetAllAdminUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Avatar,
			pq.Array(&i.Roles),
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSpacesWithStats = `-- name: GetAllSpacesWithStats :many

SELECT
    s.id, s.name, s.slug, s.description, s.type, s.logo, s.cover_image, s.location, s.website, s.contact_email, s.phone_number, s.status, s.settings, s.created_at, s.updated_at,
    (SELECT COUNT(*) FROM users WHERE space_id = s.id) as total_users,
    (SELECT COUNT(*) FROM posts WHERE space_id = s.id AND status = 'active') as total_posts,
    (SELECT COUNT(*) FROM communities WHERE space_id = s.id) as total_communities,
    (SELECT COUNT(*) FROM groups WHERE space_id = s.id) as total_groups
FROM spaces s
ORDER BY s.created_at DESC
`

type GetAllSpacesWithStatsRow struct {
	ID               uuid.UUID             `json:"id"`
	Name             string                `json:"name"`
	Slug             string                `json:"slug"`
	Description      sql.NullString        `json:"description"`
	Type             sql.NullString        `json:"type"`
	Logo             sql.NullString        `json:"logo"`
	CoverImage       sql.NullString        `json:"cover_image"`
	Location         sql.NullString        `json:"location"`
	Website          sql.NullString        `json:"website"`
	ContactEmail     sql.NullString        `json:"contact_email"`
	PhoneNumber      sql.NullString        `json:"phone_number"`
	Status           sql.NullString        `json:"status"`
	Settings         pqtype.NullRawMessage `json:"settings"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	TotalUsers       int64                 `json:"total_users"`
	TotalPosts       int64                 `json:"total_posts"`
	TotalCommunities int64                 `json:"total_communities"`
	TotalGroups      int64                 `json:"total_groups"`
}

// Space Management Queries
func (q *Queries) GetAllSpacesWithStats(ctx context.Context) ([]GetAllSpacesWithStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSpacesWithStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSpacesWithStatsRow{}
	for rows.Next() {
		var i GetAllSpacesWithStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Logo,
			&i.CoverImage,
			&i.Location,
			&i.Website,
			&i.ContactEmail,
			&i.PhoneNumber,
			&i.Status,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalUsers,
			&i.TotalPosts,
			&i.TotalCommunities,
			&i.TotalGroups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSystemSettings = `-- name: GetAllSystemSettings :many
SELECT id, key, value, description, updated_by, created_at, updated_at FROM system_settings
ORDER BY key
`

func (q *Queries) GetAllSystemSettings(ctx context.Context) ([]SystemSetting, error) {
	rows, err := q.db.QueryContext(ctx, getAllSystemSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemSetting{}
	for rows.Next() {
		var i SystemSetting
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogs = `-- name: GetAuditLogs :many
SELECT
    al.id, al.admin_user_id, al.action, al.resource_type, al.resource_id, al.details, al.ip_address, al.user_agent, al.created_at,
    u.username,
    u.full_name
FROM audit_logs al
LEFT JOIN users u ON al.admin_user_id = u.id
WHERE
    (al.admin_user_id = $1 OR $1 = '00000000-0000-0000-0000-000000000000'::uuid)
    AND (al.resource_type = $2 OR $2 = '')
    AND (al.created_at >= $3 OR $3 IS NULL)
    AND (al.created_at <= $4 OR $4 IS NULL)
ORDER BY al.created_at DESC
LIMIT $5 OFFSET $6
`

type GetAuditLogsParams struct {
	AdminUserID  uuid.UUID `json:"admin_user_id"`
	ResourceType string    `json:"resource_type"`
	CreatedAt    time.Time `json:"created_at"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

type GetAuditLogsRow struct {
	ID           uuid.UUID             `json:"id"`
	AdminUserID  uuid.UUID             `json:"admin_user_id"`
	Action       string                `json:"action"`
	ResourceType string                `json:"resource_type"`
	ResourceID   uuid.NullUUID         `json:"resource_id"`
	Details      pqtype.NullRawMessage `json:"details"`
	IpAddress    pqtype.Inet           `json:"ip_address"`
	UserAgent    sql.NullString        `json:"user_agent"`
	CreatedAt    time.Time             `json:"created_at"`
	Username     sql.NullString        `json:"username"`
	FullName     sql.NullString        `json:"full_name"`
}

func (q *Queries) GetAuditLogs(ctx context.Context, arg GetAuditLogsParams) ([]GetAuditLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAuditLogs,
		arg.AdminUserID,
		arg.ResourceType,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsRow{}
	for rows.Next() {
		var i GetAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.AdminUserID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Username,
			&i.FullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentGrowthData = `-- name: GetContentGrowthData :many
SELECT
    DATE(created_at) as date,
    COUNT(*) FILTER (WHERE status = 'active') as active_posts,
    COUNT(*) as total_posts
FROM posts
WHERE space_id = $1
AND created_at >= $2
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetContentGrowthDataParams struct {
	SpaceID   uuid.UUID    `json:"space_id"`
	CreatedAt sql.NullTime `json:"created_at"`
}

type GetContentGrowthDataRow struct {
	Date        time.Time `json:"date"`
	ActivePosts int64     `json:"active_posts"`
	TotalPosts  int64     `json:"total_posts"`
}

func (q *Queries) GetContentGrowthData(ctx context.Context, arg GetContentGrowthDataParams) ([]GetContentGrowthDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentGrowthData, arg.SpaceID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentGrowthDataRow{}
	for rows.Next() {
		var i GetContentGrowthDataRow
		if err := rows.Scan(&i.Date, &i.ActivePosts, &i.TotalPosts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentReportByID = `-- name: GetContentReportByID :one
SELECT
    r.id, r.space_id, r.reporter_id, r.content_type, r.content_id, r.reason, r.description, r.status, r.priority, r.reviewed_by, r.reviewed_at, r.moderation_notes, r.actions_taken, r.created_at, r.updated_at,
    u.username as reporter_username,
    u.full_name as reporter_name
FROM reports r
LEFT JOIN users u ON r.reporter_id = u.id
WHERE r.id = $1
`

type GetContentReportByIDRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	ReporterID       uuid.UUID             `json:"reporter_id"`
	ContentType      string                `json:"content_type"`
	ContentID        uuid.UUID             `json:"content_id"`
	Reason           string                `json:"reason"`
	Description      sql.NullString        `json:"description"`
	Status           sql.NullString        `json:"status"`
	Priority         sql.NullString        `json:"priority"`
	ReviewedBy       uuid.NullUUID         `json:"reviewed_by"`
	ReviewedAt       sql.NullTime          `json:"reviewed_at"`
	ModerationNotes  sql.NullString        `json:"moderation_notes"`
	ActionsTaken     pqtype.NullRawMessage `json:"actions_taken"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ReporterUsername sql.NullString        `json:"reporter_username"`
	ReporterName     sql.NullString        `json:"reporter_name"`
}

func (q *Queries) GetContentReportByID(ctx context.Context, id uuid.UUID) (GetContentReportByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getContentReportByID, id)
	var i GetContentReportByIDRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReporterUsername,
		&i.ReporterName,
	)
	return i, err
}

const getContentReports = `-- name: GetContentReports :many
SELECT
    r.id, r.space_id, r.reporter_id, r.content_type, r.content_id, r.reason, r.description, r.status, r.priority, r.reviewed_by, r.reviewed_at, r.moderation_notes, r.actions_taken, r.created_at, r.updated_at,
    u.username as reporter_username,
    u.full_name as reporter_name,
    reviewer.username as reviewer_username
FROM reports r
LEFT JOIN users u ON r.reporter_id = u.id
LEFT JOIN users reviewer ON r.reviewed_by = reviewer.id
WHERE
    (r.space_id = $1 OR $1 = '00000000-0000-0000-0000-000000000000'::uuid)
    AND (r.status = $2 OR $2 = '')
    AND (r.content_type = $3 OR $3 = '')
ORDER BY r.created_at DESC
LIMIT $4 OFFSET $5
`

type GetContentReportsParams struct {
	SpaceID     uuid.UUID      `json:"space_id"`
	Status      sql.NullString `json:"status"`
	ContentType string         `json:"content_type"`
	Limit       int32          `json:"limit"`
	Offset      int32          `json:"offset"`
}

type GetContentReportsRow struct {
	ID               uuid.UUID             `json:"id"`
	SpaceID          uuid.UUID             `json:"space_id"`
	ReporterID       uuid.UUID             `json:"reporter_id"`
	ContentType      string                `json:"content_type"`
	ContentID        uuid.UUID             `json:"content_id"`
	Reason           string                `json:"reason"`
	Description      sql.NullString        `json:"description"`
	Status           sql.NullString        `json:"status"`
	Priority         sql.NullString        `json:"priority"`
	ReviewedBy       uuid.NullUUID         `json:"reviewed_by"`
	ReviewedAt       sql.NullTime          `json:"reviewed_at"`
	ModerationNotes  sql.NullString        `json:"moderation_notes"`
	ActionsTaken     pqtype.NullRawMessage `json:"actions_taken"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ReporterUsername sql.NullString        `json:"reporter_username"`
	ReporterName     sql.NullString        `json:"reporter_name"`
	ReviewerUsername sql.NullString        `json:"reviewer_username"`
}

func (q *Queries) GetContentReports(ctx context.Context, arg GetContentReportsParams) ([]GetContentReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentReports,
		arg.SpaceID,
		arg.Status,
		arg.ContentType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentReportsRow{}
	for rows.Next() {
		var i GetContentReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.ReporterID,
			&i.ContentType,
			&i.ContentID,
			&i.Reason,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ModerationNotes,
			&i.ActionsTaken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReporterUsername,
			&i.ReporterName,
			&i.ReviewerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportStats = `-- name: GetReportStats :one
SELECT
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'resolved') as resolved_count,
    COUNT(*) FILTER (WHERE status = 'escalated') as escalated_count,
    COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed_count
FROM reports
WHERE space_id = $1
`

type GetReportStatsRow struct {
	PendingCount   int64 `json:"pending_count"`
	ResolvedCount  int64 `json:"resolved_count"`
	EscalatedCount int64 `json:"escalated_count"`
	DismissedCount int64 `json:"dismissed_count"`
}

func (q *Queries) GetReportStats(ctx context.Context, spaceID uuid.UUID) (GetReportStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getReportStats, spaceID)
	var i GetReportStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.ResolvedCount,
		&i.EscalatedCount,
		&i.DismissedCount,
	)
	return i, err
}

const getSpaceActivities = `-- name: GetSpaceActivities :many
SELECT
    sa.id, sa.space_id, sa.activity_type, sa.actor_id, sa.actor_name, sa.description, sa.metadata, sa.created_at,
    u.username,
    u.avatar
FROM space_activities sa
LEFT JOIN users u ON sa.actor_id = u.id
WHERE
    sa.space_id = $1
    AND (sa.activity_type = $2 OR $2 = '')
    AND (sa.created_at >= $3 OR $3 IS NULL)
ORDER BY sa.created_at DESC
LIMIT $4 OFFSET $5
`

type GetSpaceActivitiesParams struct {
	SpaceID      uuid.UUID `json:"space_id"`
	ActivityType string    `json:"activity_type"`
	CreatedAt    time.Time `json:"created_at"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

type GetSpaceActivitiesRow struct {
	ID           uuid.UUID             `json:"id"`
	SpaceID      uuid.UUID             `json:"space_id"`
	ActivityType string                `json:"activity_type"`
	ActorID      uuid.NullUUID         `json:"actor_id"`
	ActorName    sql.NullString        `json:"actor_name"`
	Description  string                `json:"description"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	CreatedAt    time.Time             `json:"created_at"`
	Username     sql.NullString        `json:"username"`
	Avatar       sql.NullString        `json:"avatar"`
}

func (q *Queries) GetSpaceActivities(ctx context.Context, arg GetSpaceActivitiesParams) ([]GetSpaceActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpaceActivities,
		arg.SpaceID,
		arg.ActivityType,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpaceActivitiesRow{}
	for rows.Next() {
		var i GetSpaceActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SpaceID,
			&i.ActivityType,
			&i.ActorID,
			&i.ActorName,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.Username,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpaceWithStats = `-- name: GetSpaceWithStats :one
SELECT
    s.id, s.name, s.slug, s.description, s.type, s.logo, s.cover_image, s.location, s.website, s.contact_email, s.phone_number, s.status, s.settings, s.created_at, s.updated_at,
    (SELECT COUNT(*) FROM users WHERE space_id = s.id) as total_users,
    (SELECT COUNT(*) FROM posts WHERE space_id = s.id AND status = 'active') as total_posts,
    (SELECT COUNT(*) FROM communities WHERE space_id = s.id) as total_communities,
    (SELECT COUNT(*) FROM groups WHERE space_id = s.id) as total_groups,
    (SELECT COUNT(*) FROM users WHERE space_id = s.id AND created_at >= NOW() - INTERVAL '7 days') as new_users_week
FROM spaces s
WHERE s.id = $1
`

type GetSpaceWithStatsRow struct {
	ID               uuid.UUID             `json:"id"`
	Name             string                `json:"name"`
	Slug             string                `json:"slug"`
	Description      sql.NullString        `json:"description"`
	Type             sql.NullString        `json:"type"`
	Logo             sql.NullString        `json:"logo"`
	CoverImage       sql.NullString        `json:"cover_image"`
	Location         sql.NullString        `json:"location"`
	Website          sql.NullString        `json:"website"`
	ContactEmail     sql.NullString        `json:"contact_email"`
	PhoneNumber      sql.NullString        `json:"phone_number"`
	Status           sql.NullString        `json:"status"`
	Settings         pqtype.NullRawMessage `json:"settings"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	TotalUsers       int64                 `json:"total_users"`
	TotalPosts       int64                 `json:"total_posts"`
	TotalCommunities int64                 `json:"total_communities"`
	TotalGroups      int64                 `json:"total_groups"`
	NewUsersWeek     int64                 `json:"new_users_week"`
}

func (q *Queries) GetSpaceWithStats(ctx context.Context, id uuid.UUID) (GetSpaceWithStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSpaceWithStats, id)
	var i GetSpaceWithStatsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Logo,
		&i.CoverImage,
		&i.Location,
		&i.Website,
		&i.ContactEmail,
		&i.PhoneNumber,
		&i.Status,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalUsers,
		&i.TotalPosts,
		&i.TotalCommunities,
		&i.TotalGroups,
		&i.NewUsersWeek,
	)
	return i, err
}

const getSystemSetting = `-- name: GetSystemSetting :one

SELECT id, key, value, description, updated_by, created_at, updated_at FROM system_settings
WHERE key = $1
LIMIT 1
`

// System Settings Queries
func (q *Queries) GetSystemSetting(ctx context.Context, key string) (SystemSetting, error) {
	row := q.db.QueryRowContext(ctx, getSystemSetting, key)
	var i SystemSetting
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDetails = `-- name: GetUserDetails :one
SELECT
    u.id, u.space_id, u.username, u.email, u.password, u.full_name, u.avatar, u.bio, u.verified, u.roles, u.level, u.department, u.major, u.year, u.interests, u.followers_count, u.following_count, u.mentor_status, u.tutor_status, u.status, u.settings, u.phone_number, u.additional_phone_number, u.created_at, u.updated_at, u.is_locked, u.locked_until, u.failed_login_attempts, u.last_failed_login, u.suspended_until,
    (SELECT COUNT(*) FROM posts WHERE author_id = u.id AND status = 'active') as posts_count,
    (SELECT COUNT(*) FROM likes WHERE user_id = u.id) as likes_given,
    (SELECT COUNT(*) FROM comments WHERE author_id = u.id AND status = 'active') as comments_count
FROM users u
WHERE u.id = $1
`

type GetUserDetailsRow struct {
	ID                    uuid.UUID             `json:"id"`
	SpaceID               uuid.UUID             `json:"space_id"`
	Username              string                `json:"username"`
	Email                 string                `json:"email"`
	Password              string                `json:"password"`
	FullName              string                `json:"full_name"`
	Avatar                sql.NullString        `json:"avatar"`
	Bio                   sql.NullString        `json:"bio"`
	Verified              sql.NullBool          `json:"verified"`
	Roles                 []string              `json:"roles"`
	Level                 sql.NullString        `json:"level"`
	Department            sql.NullString        `json:"department"`
	Major                 sql.NullString        `json:"major"`
	Year                  sql.NullInt32         `json:"year"`
	Interests             []string              `json:"interests"`
	FollowersCount        sql.NullInt32         `json:"followers_count"`
	FollowingCount        sql.NullInt32         `json:"following_count"`
	MentorStatus          sql.NullString        `json:"mentor_status"`
	TutorStatus           sql.NullString        `json:"tutor_status"`
	Status                sql.NullString        `json:"status"`
	Settings              pqtype.NullRawMessage `json:"settings"`
	PhoneNumber           string                `json:"phone_number"`
	AdditionalPhoneNumber sql.NullString        `json:"additional_phone_number"`
	CreatedAt             sql.NullTime          `json:"created_at"`
	UpdatedAt             sql.NullTime          `json:"updated_at"`
	IsLocked              bool                  `json:"is_locked"`
	LockedUntil           sql.NullTime          `json:"locked_until"`
	FailedLoginAttempts   int32                 `json:"failed_login_attempts"`
	LastFailedLogin       sql.NullTime          `json:"last_failed_login"`
	SuspendedUntil        sql.NullTime          `json:"suspended_until"`
	PostsCount            int64                 `json:"posts_count"`
	LikesGiven            int64                 `json:"likes_given"`
	CommentsCount         int64                 `json:"comments_count"`
}

func (q *Queries) GetUserDetails(ctx context.Context, id uuid.UUID) (GetUserDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetails, id)
	var i GetUserDetailsRow
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
		&i.PostsCount,
		&i.LikesGiven,
		&i.CommentsCount,
	)
	return i, err
}

const getUserGrowthData = `-- name: GetUserGrowthData :many
SELECT
    DATE(created_at) as date,
    COUNT(*) as new_users
FROM users
WHERE space_id = $1
AND created_at >= $2
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetUserGrowthDataParams struct {
	SpaceID   uuid.UUID    `json:"space_id"`
	CreatedAt sql.NullTime `json:"created_at"`
}

type GetUserGrowthDataRow struct {
	Date     time.Time `json:"date"`
	NewUsers int64     `json:"new_users"`
}

func (q *Queries) GetUserGrowthData(ctx context.Context, arg GetUserGrowthDataParams) ([]GetUserGrowthDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserGrowthData, arg.SpaceID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrowthDataRow{}
	for rows.Next() {
		var i GetUserGrowthDataRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSuspensions = `-- name: GetUserSuspensions :many
SELECT
    us.id, us.user_id, us.suspended_by, us.reason, us.notes, us.suspended_at, us.suspended_until, us.is_permanent, us.created_at,
    u.username,
    u.full_name,
    admin.username as suspended_by_username
FROM user_suspensions us
JOIN users u ON us.user_id = u.id
JOIN users admin ON us.suspended_by = admin.id
WHERE us.user_id = $1
ORDER BY us.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserSuspensionsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetUserSuspensionsRow struct {
	ID                  uuid.UUID      `json:"id"`
	UserID              uuid.UUID      `json:"user_id"`
	SuspendedBy         uuid.UUID      `json:"suspended_by"`
	Reason              string         `json:"reason"`
	Notes               sql.NullString `json:"notes"`
	SuspendedAt         time.Time      `json:"suspended_at"`
	SuspendedUntil      sql.NullTime   `json:"suspended_until"`
	IsPermanent         bool           `json:"is_permanent"`
	CreatedAt           time.Time      `json:"created_at"`
	Username            string         `json:"username"`
	FullName            string         `json:"full_name"`
	SuspendedByUsername string         `json:"suspended_by_username"`
}

func (q *Queries) GetUserSuspensions(ctx context.Context, arg GetUserSuspensionsParams) ([]GetUserSuspensionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSuspensions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSuspensionsRow{}
	for rows.Next() {
		var i GetUserSuspensionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SuspendedBy,
			&i.Reason,
			&i.Notes,
			&i.SuspendedAt,
			&i.SuspendedUntil,
			&i.IsPermanent,
			&i.CreatedAt,
			&i.Username,
			&i.FullName,
			&i.SuspendedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserSuperAdmin = `-- name: IsUserSuperAdmin :one
SELECT EXISTS(
    SELECT 1 FROM users
    WHERE id = $1
    AND status = 'active'
    AND 'super_admin' = ANY(roles)
) as is_super_admin
`

func (q *Queries) IsUserSuperAdmin(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserSuperAdmin, id)
	var is_super_admin bool
	err := row.Scan(&is_super_admin)
	return is_super_admin, err
}

const liftSuspension = `-- name: LiftSuspension :exec
UPDATE users
SET
    status = 'active',
    suspended_until = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) LiftSuspension(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, liftSuspension, id)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE users
SET
    password = $2,
    updated_at = NOW()
WHERE id = $1
`

type ResetUserPasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, resetUserPassword, arg.ID, arg.Password)
	return err
}

const searchUsersAdmin = `-- name: SearchUsersAdmin :many

SELECT
    u.id,
    u.username,
    u.email,
    u.full_name,
    u.avatar,
    u.verified,
    u.roles,
    u.status,
    u.suspended_until,
    u.created_at,
    u.followers_count,
    u.following_count,
    (SELECT COUNT(*) FROM posts WHERE author_id = u.id AND status = 'active') as posts_count
FROM users u
WHERE
    u.space_id = $1
    AND (
        u.full_name ILIKE '%' || $2 || '%'
        OR u.username ILIKE '%' || $2 || '%'
        OR u.email ILIKE '%' || $2 || '%'
    )
    AND (u.status = $3 OR $3 = '')
    AND (u.roles && $4 OR array_length($4::text[], 1) IS NULL)
ORDER BY u.created_at DESC
LIMIT $5 OFFSET $6
`

type SearchUsersAdminParams struct {
	SpaceID uuid.UUID      `json:"space_id"`
	Column2 sql.NullString `json:"column_2"`
	Status  sql.NullString `json:"status"`
	Roles   []string       `json:"roles"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type SearchUsersAdminRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	FullName       string         `json:"full_name"`
	Avatar         sql.NullString `json:"avatar"`
	Verified       sql.NullBool   `json:"verified"`
	Roles          []string       `json:"roles"`
	Status         sql.NullString `json:"status"`
	SuspendedUntil sql.NullTime   `json:"suspended_until"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	PostsCount     int64          `json:"posts_count"`
}

// User Management Queries (Admin variant with extended filtering)
func (q *Queries) SearchUsersAdmin(ctx context.Context, arg SearchUsersAdminParams) ([]SearchUsersAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsersAdmin,
		arg.SpaceID,
		arg.Column2,
		arg.Status,
		pq.Array(arg.Roles),
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersAdminRow{}
	for rows.Next() {
		var i SearchUsersAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Avatar,
			&i.Verified,
			pq.Array(&i.Roles),
			&i.Status,
			&i.SuspendedUntil,
			&i.CreatedAt,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.PostsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContentReportPriority = `-- name: UpdateContentReportPriority :one
UPDATE reports
SET
    priority = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type UpdateContentReportPriorityParams struct {
	ID       uuid.UUID      `json:"id"`
	Priority sql.NullString `json:"priority"`
}

func (q *Queries) UpdateContentReportPriority(ctx context.Context, arg UpdateContentReportPriorityParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, updateContentReportPriority, arg.ID, arg.Priority)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateContentReportStatus = `-- name: UpdateContentReportStatus :one
UPDATE reports
SET
    status = $2,
    reviewed_by = $3,
    moderation_notes = $4,
    reviewed_at = CASE WHEN $2 IN ('resolved', 'dismissed') THEN NOW() ELSE reviewed_at END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type UpdateContentReportStatusParams struct {
	ID              uuid.UUID      `json:"id"`
	Status          sql.NullString `json:"status"`
	ReviewedBy      uuid.NullUUID  `json:"reviewed_by"`
	ModerationNotes sql.NullString `json:"moderation_notes"`
}

func (q *Queries) UpdateContentReportStatus(ctx context.Context, arg UpdateContentReportStatusParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, updateContentReportStatus,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ModerationNotes,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateContentReportWithAction = `-- name: UpdateContentReportWithAction :one
UPDATE reports
SET
    status = $2,
    reviewed_by = $3,
    moderation_notes = $4,
    actions_taken = $5,
    reviewed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, space_id, reporter_id, content_type, content_id, reason, description, status, priority, reviewed_by, reviewed_at, moderation_notes, actions_taken, created_at, updated_at
`

type UpdateContentReportWithActionParams struct {
	ID              uuid.UUID             `json:"id"`
	Status          sql.NullString        `json:"status"`
	ReviewedBy      uuid.NullUUID         `json:"reviewed_by"`
	ModerationNotes sql.NullString        `json:"moderation_notes"`
	ActionsTaken    pqtype.NullRawMessage `json:"actions_taken"`
}

func (q *Queries) UpdateContentReportWithAction(ctx context.Context, arg UpdateContentReportWithActionParams) (Report, error) {
	row := q.db.QueryRowContext(ctx, updateContentReportWithAction,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ModerationNotes,
		arg.ActionsTaken,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.ReporterID,
		&i.ContentType,
		&i.ContentID,
		&i.Reason,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ModerationNotes,
		&i.ActionsTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserAccountStatus = `-- name: UpdateUserAccountStatus :exec
UPDATE users
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserAccountStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateUserAccountStatus(ctx context.Context, arg UpdateUserAccountStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAccountStatus, arg.ID, arg.Status)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET
    roles = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, space_id, username, email, password, full_name, avatar, bio, verified, roles, level, department, major, year, interests, followers_count, following_count, mentor_status, tutor_status, status, settings, phone_number, additional_phone_number, created_at, updated_at, is_locked, locked_until, failed_login_attempts, last_failed_login, suspended_until
`

type UpdateUserRoleParams struct {
	ID    uuid.UUID `json:"id"`
	Roles []string  `json:"roles"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserRole, arg.ID, pq.Array(arg.Roles))
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpaceID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.Avatar,
		&i.Bio,
		&i.Verified,
		pq.Array(&i.Roles),
		&i.Level,
		&i.Department,
		&i.Major,
		&i.Year,
		pq.Array(&i.Interests),
		&i.FollowersCount,
		&i.FollowingCount,
		&i.MentorStatus,
		&i.TutorStatus,
		&i.Status,
		&i.Settings,
		&i.PhoneNumber,
		&i.AdditionalPhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocked,
		&i.LockedUntil,
		&i.FailedLoginAttempts,
		&i.LastFailedLogin,
		&i.SuspendedUntil,
	)
	return i, err
}

const upsertSystemSetting = `-- name: UpsertSystemSetting :one
INSERT INTO system_settings (key, value, description, updated_by)
VALUES ($1, $2, $3, $4)
ON CONFLICT (key) DO UPDATE SET
    value = EXCLUDED.value,
    updated_by = EXCLUDED.updated_by,
    updated_at = NOW()
RETURNING id, key, value, description, updated_by, created_at, updated_at
`

type UpsertSystemSettingParams struct {
	Key         string          `json:"key"`
	Value       json.RawMessage `json:"value"`
	Description sql.NullString  `json:"description"`
	UpdatedBy   uuid.NullUUID   `json:"updated_by"`
}

func (q *Queries) UpsertSystemSetting(ctx context.Context, arg UpsertSystemSettingParams) (SystemSetting, error) {
	row := q.db.QueryRowContext(ctx, upsertSystemSetting,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.UpdatedBy,
	)
	var i SystemSetting
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
